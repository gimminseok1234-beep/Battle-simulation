<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>아레나 전투 시뮬레이터 (Firebase)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.7.77/Tone.js"></script>
    <style>
        /* 기본 스타일 */
        body { background-color: #111827; color: #d1d5db; font-family: 'Inter', sans-serif; }

        /* 홈 화면 스타일 */
        #homeScreen { display: flex; }
        #editorScreen { display: none; }

        .map-card {
            background-color: #1f2937;
            border: 1px solid #374151;
            transition: transform 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
            position: relative;
        }
        .map-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.2), 0 4px 6px -2px rgba(0, 0, 0, 0.1);
        }
        .map-preview-canvas {
            background-color: #111827;
            image-rendering: pixelated; /* 픽셀화된 렌더링 */
            width: 100%;
            aspect-ratio: 3 / 4; /* 맵 비율 유지 */
        }
        .map-menu-button {
            position: absolute;
            top: 0.5rem;
            right: 0.5rem;
            background-color: rgba(31, 41, 55, 0.7);
        }
        .map-menu {
            display: none;
            position: absolute;
            top: 2.5rem;
            right: 0.5rem;
            background-color: #374151;
            z-index: 10;
        }

        /* 에디터 스타일 */
        .tool-btn.selected { background-color: #3b82f6; color: white; }
        .tool-btn.team-a.selected { background-color: #ef4444; }
        .tool-btn.team-b.selected { background-color: #3b82f6; }
        .tool-btn.team-c.selected { background-color: #22c55e; }
        .tool-btn.team-d.selected { background-color: #eab308; }
        #gameCanvas { background-color: #1f2937; image-rendering: pixelated; cursor: crosshair; }
        input[type="number"], select { background-color: #374151; color: white; border: 1px solid #4b5563; }
        .category-header { cursor: pointer; user-select: none; padding: 8px; border-radius: 4px; font-weight: bold; margin-bottom: 8px; transition: background-color: 0.2s; }
        .category-header:hover { background-color: #4b5563; }
        .category-content { max-height: 0; overflow: hidden; transition: max-height 0.3s ease-in-out; }
        input[type="color"] {
            -webkit-appearance: none; -moz-appearance: none; appearance: none;
            width: 32px; height: 32px; background-color: transparent;
            border: none; cursor: pointer;
        }
        input[type="color"]::-webkit-color-swatch { border-radius: 6px; border: 1px solid #4b5563; }
        input[type="color"]::-moz-color-swatch { border-radius: 6px; border: 1px solid #4b5563; }

        /* 모달 스타일 */
        .modal {
            display: none; position: fixed; z-index: 100; left: 0; top: 0;
            width: 100%; height: 100%;
            overflow: auto; background-color: rgba(0,0,0,0.6);
            align-items: center; justify-content: center;
        }
        .modal-content {
            background-color: #1f2937; padding: 2rem; border-radius: 0.5rem;
            border: 1px solid #4b5563; width: 90%; max-width: 400px;
        }
        .toggle-label {
            position: relative; display: inline-flex; align-items: center; cursor: pointer;
        }
        .toggle-input { opacity: 0; width: 0; height: 0; }
        .toggle-slider {
            width: 44px; height: 24px; background-color: #4b5563;
            transition: .4s; border-radius: 24px; position: relative;
        }
        .toggle-slider:before {
            position: absolute; content: ""; height: 18px; width: 18px;
            left: 3px; bottom: 3px; background-color: white;
            transition: .4s; border-radius: 50%;
        }
        .toggle-input:checked + .toggle-slider { background-color: #ef4444; }
        .toggle-input:checked + .toggle-slider:before { transform: translateX(20px); }

        input[type=range] {
            -webkit-appearance: none;
            background: transparent;
        }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 16px;
            width: 16px;
            border-radius: 50%;
            background: #a78bfa;
            cursor: pointer;
            margin-top: -6px;
        }
        input[type=range]::-moz-range-thumb {
            height: 16px;
            width: 16px;
            border-radius: 50%;
            background: #a78bfa;
            cursor: pointer;
        }
        input[type=range]::-webkit-slider-runnable-track {
            width: 100%;
            height: 4px;
            cursor: pointer;
            background: #4b5563;
            border-radius: 4px;
        }
    </style>
</head>
<body class="p-4">

    <div id="homeScreen" class="flex-col items-center justify-center min-h-screen w-full">
        <h1 class="text-3xl font-bold mb-2 text-center">아레나 전투 시뮬레이터</h1>
       
        <div id="userInfo" class="text-center mb-4 h-10">
            <p id="loadingStatus" class="text-gray-400">Firebase 인증 중...</p>
            <button id="googleLoginBtn" class="hidden bg-white text-black font-bold py-2 px-4 rounded-lg flex items-center justify-center mx-auto hover:bg-gray-200 transition">
                <img src="https://www.gstatic.com/firebasejs/ui/2.0.0/images/auth/google.svg" class="w-5 h-5 mr-2">
                Google 계정으로 로그인
            </button>
            <div id="userDetails" class="hidden items-center justify-center">
                <img id="userPhoto" class="w-8 h-8 rounded-full mr-2">
                <span id="userName" class="text-white font-semibold"></span>
                <button id="logoutBtn" class="ml-4 bg-red-600 hover:bg-red-700 text-white font-bold py-1 px-3 rounded">로그아웃</button>
            </div>
        </div>

        <div id="mapGrid" class="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-5 xl:grid-cols-6 gap-6 w-full max-w-7xl mx-auto">
            <button id="addNewMapCard" class="flex flex-col items-center justify-center p-4 rounded-lg border-2 border-dashed border-gray-600 hover:bg-gray-800 hover:border-gray-500 transition-colors aspect-[3/4] hidden">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-12 w-12 text-gray-500 mb-2" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 4v16m8-8H4" />
                </svg>
                <span class="text-gray-400 font-semibold">새 맵 추가</span>
            </button>
        </div>
    </div>

    <div id="editorScreen" class="flex-col items-center gap-4 w-full max-w-7xl mx-auto">
        <div id="toolbar" class="bg-gray-800 p-2 rounded-lg shadow-lg flex items-center justify-between gap-2 w-full flex-wrap">
            <div class="flex items-center gap-4 flex-wrap">
                 <button id="backToHomeBtn" class="bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded">홈으로</button>
                 <button id="saveMapBtn" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded">저장</button>
                 <div class="flex items-center gap-2">
                     <label for="actionCamToggle" class="relative inline-flex items-center cursor-pointer">
                         <input type="checkbox" id="actionCamToggle" class="sr-only peer">
                         <div class="w-11 h-6 bg-gray-600 rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-green-500"></div>
                         <span class="ml-3 text-sm font-medium text-gray-300">액션캠</span>
                     </label>
                 </div>
                <button id="simStartBtn" class="bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded">시작</button>
                <button id="simPauseBtn" class="bg-orange-600 hover:bg-orange-700 text-white font-bold py-2 px-4 rounded hidden">일시정지</button>
                <button id="simPlayBtn" class="bg-sky-600 hover:bg-sky-700 text-white font-bold py-2 px-4 rounded hidden">재생</button>
                <button id="simPlacementResetBtn" class="bg-purple-600 hover:bg-purple-700 text-white font-bold py-2 px-4 rounded">배치 초기화</button>
                <button id="simResetBtn" class="bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-4 rounded">맵 초기화</button>
            </div>
             <div id="statusText" class="text-yellow-400 font-semibold text-center flex-grow">에디터 모드</div>
            <div class="flex items-center gap-4">
                <button id="muteBtn" class="p-2 rounded-full hover:bg-gray-700">
                    <svg id="soundOnIcon" xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                        <path stroke-linecap="round" stroke-linejoin="round" d="M15.536 8.464a5 5 0 010 7.072m2.828-9.9a9 9 0 010 12.728M5.586 15H4a1 1 0 01-1-1v-4a1 1 0 011-1h1.586l4.707-4.707C10.923 3.663 12 4.109 12 5v14c0 .891-1.077 1.337-1.707.707L5.586 15z" />
                    </svg>
                    <svg id="soundOffIcon" xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 hidden" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                        <path stroke-linecap="round" stroke-linejoin="round" d="M5.586 15H4a1 1 0 01-1-1v-4a1 1 0 011-1h1.586l4.707-4.707C10.923 3.663 12 4.109 12 5v14c0 .891-1.077 1.337-1.707.707L5.586 15z" />
                        <path stroke-linecap="round" stroke-linejoin="round" d="M17 14l2-2m0 0l2-2m-2 2l-2-2m2 2l2 2" />
                    </svg>
                </button>
                <button id="mapSettingsBtn" class="p-2 rounded-full hover:bg-gray-700">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                        <path stroke-linecap="round" stroke-linejoin="round" d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z" />
                        <path stroke-linecap="round" stroke-linejoin="round" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" />
                    </svg>
                </button>
            </div>
        </div>

        <div class="flex items-start gap-4 w-full">
            <div id="toolbox" class="bg-gray-800 p-4 rounded-lg shadow-lg flex flex-col gap-1 w-48">
                <div>
                    <h3 class="category-header bg-teal-800" data-target="category-basic-tiles">기본 타일</h3>
                    <div id="category-basic-tiles" class="category-content">
                        <div class="flex items-center justify-between gap-2 mb-1">
                            <button class="tool-btn flex-grow text-left p-2 rounded hover:bg-gray-700" data-tool="tile" data-type="FLOOR">바닥</button>
                            <input type="color" id="floorColorPicker" value="#4a5568" title="바닥 색상 선택">
                        </div>
                        <div class="flex items-center justify-between gap-2">
                            <button class="tool-btn flex-grow text-left p-2 rounded hover:bg-gray-700" data-tool="tile" data-type="WALL">벽</button>
                            <input type="color" id="wallColorPicker" value="#2d3748" title="벽 색상 선택">
                        </div>
                    </div>
                </div>
                 <div>
                    <h3 class="category-header bg-sky-800" data-target="category-special-tiles">특수 타일</h3>
                    <div id="category-special-tiles" class="category-content">
                        <button class="tool-btn w-full text-left p-2 rounded hover:bg-gray-700" data-tool="tile" data-type="CRACKED_WALL">금 간 벽</button>
                        <button class="tool-btn w-full text-left p-2 rounded hover:bg-gray-700" data-tool="tile" data-type="LAVA">용암</button>
                        <button class="tool-btn w-full text-left p-2 rounded hover:bg-gray-700" data-tool="tile" data-type="TELEPORTER">순간이동</button>
                        <button class="tool-btn w-full text-left p-2 rounded hover:bg-gray-700" data-tool="tile" data-type="HEAL_PACK">힐 팩</button>
                        <div class="flex items-center gap-1 mt-1">
                            <button class="tool-btn flex-grow text-left p-2 rounded hover:bg-gray-700" data-tool="growing_field">성장형 자기장</button>
                            <button id="growingFieldSettingsBtn" class="p-2 rounded hover:bg-gray-600 hidden">⚙️</button>
                        </div>
                        <div class="flex items-center gap-1 mt-1">
                            <button class="tool-btn flex-grow text-left p-2 rounded hover:bg-gray-700" data-tool="auto_field">자동 자기장</button>
                            <button id="autoFieldSettingsBtn" class="p-2 rounded hover:bg-gray-600 hidden">⚙️</button>
                        </div>
                        <div class="flex items-center gap-2 mt-2">
                            <button class="tool-btn w-full text-left p-2 rounded hover:bg-gray-700" data-tool="tile" data-type="REPLICATION_TILE">+N 복제</button>
                            <input type="number" id="replicationValue" value="2" class="p-1 rounded w-16">
                        </div>
                    </div>
                </div>
                 <div>
                    <h3 class="category-header bg-purple-800" data-target="category-structures">구조물</h3>
                    <div id="category-structures" class="category-content">
                        <button class="tool-btn team-a w-full text-left p-2 rounded hover:bg-red-500" data-tool="nexus" data-team="A">빨강 넥서스</button>
                        <button class="tool-btn team-b w-full text-left p-2 rounded hover:bg-blue-500" data-tool="nexus" data-team="B">파랑 넥서스</button>
                        <button class="tool-btn team-c w-full text-left p-2 rounded hover:bg-green-500" data-tool="nexus" data-team="C">초록 넥서스</button>
                        <button class="tool-btn team-d w-full text-left p-2 rounded hover:bg-yellow-500" data-tool="nexus" data-team="D">노랑 넥서스</button>
                    </div>
                </div>
                <div>
                    <h3 class="category-header bg-rose-800" data-target="category-units">유닛</h3>
                    <div id="category-units" class="category-content">
                        <button class="tool-btn team-a w-full text-left p-2 rounded hover:bg-red-500" data-tool="unit" data-team="A">빨강 유닛</button>
                        <button class="tool-btn team-b w-full text-left p-2 rounded hover:bg-blue-500" data-tool="unit" data-team="B">파랑 유닛</button>
                        <button class="tool-btn team-c w-full text-left p-2 rounded hover:bg-green-500" data-tool="unit" data-team="C">초록 유닛</button>
                        <button class="tool-btn team-d w-full text-left p-2 rounded hover:bg-yellow-500" data-tool="unit" data-team="D">노랑 유닛</button>
                    </div>
                </div>
                <div>
                    <h3 class="category-header bg-indigo-800" data-target="category-objects">무기</h3>
                    <div id="category-objects" class="category-content">
                        <button class="tool-btn w-full text-left p-2 rounded hover:bg-gray-700" data-tool="weapon" data-type="sword">검</button>
                        <button class="tool-btn w-full text-left p-2 rounded hover:bg-gray-700" data-tool="weapon" data-type="bow">활</button>
                        <button class="tool-btn w-full text-left p-2 rounded hover:bg-gray-700" data-tool="weapon" data-type="dual_swords">쌍검</button>
                        <button class="tool-btn w-full text-left p-2 rounded hover:bg-gray-700" data-tool="weapon" data-type="staff">지팡이</button>
                        <div class="flex items-center gap-1">
                            <button class="tool-btn flex-grow text-left p-2 rounded hover:bg-gray-700" data-tool="weapon" data-type="hadoken">장풍</button>
                            <button id="hadokenSettingsBtn" class="p-2 rounded hover:bg-gray-600 hidden">⚙️</button>
                        </div>
                        <button class="tool-btn w-full text-left p-2 rounded hover:bg-gray-700" data-tool="weapon" data-type="shuriken">표창</button>
                        <button class="tool-btn w-full text-left p-2 rounded hover:bg-gray-700" data-tool="weapon" data-type="crown">왕관</button>
                    </div>
                </div>
                <div>
                    <h3 class="category-header bg-slate-800" data-target="category-utils">기타</h3>
                    <div id="category-utils" class="category-content">
                         <button class="tool-btn w-full text-left p-2 rounded hover:bg-gray-700" data-tool="erase">지우개</button>
                    </div>
                </div>
            </div>

            <div class="flex flex-col items-center flex-grow">
                <canvas id="gameCanvas" class="border-2 border-gray-600 rounded-lg"></canvas>
            </div>
        </div>
    </div>

    <div id="mapSettingsModal" class="modal">
        <div class="modal-content flex flex-col gap-4">
            <h2 class="text-xl font-bold text-white">맵 설정 ⚙️</h2>
            <div>
                <label for="widthInput" class="block mb-2 text-sm font-medium text-gray-300">가로 (px)</label>
                <input type="number" id="widthInput" class="w-full p-2.5 rounded bg-gray-700 border-gray-600">
            </div>
            <div>
                <label for="heightInput" class="block mb-2 text-sm font-medium text-gray-300">세로 (px)</label>
                <input type="number" id="heightInput" class="w-full p-2.5 rounded bg-gray-700 border-gray-600">
            </div>
             <div class="flex items-center justify-between mt-2">
                <label class="toggle-label text-sm font-medium text-gray-300">
                    유닛 사망 효과음
                </label>
                <label class="toggle-label">
                    <input type="checkbox" id="killSoundToggle" class="toggle-input" checked>
                    <span class="toggle-slider"></span>
                </label>
            </div>
            <div class="flex justify-end gap-2 mt-4">
                <button id="closeMapSettingsModal" class="bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded">닫기</button>
                <button id="resizeBtn" class="bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-4 rounded">크기 적용</button>
            </div>
        </div>
    </div>
    <div id="newMapModal" class="modal">
        <div class="modal-content flex flex-col gap-4">
            <h2 class="text-xl font-bold text-white">새 맵 생성</h2>
            <div>
                <label for="newMapName" class="block mb-2 text-sm font-medium text-gray-300">맵 이름</label>
                <input type="text" id="newMapName" class="w-full p-2.5 rounded bg-gray-700 border-gray-600 placeholder-gray-400 text-white" placeholder="나만의 맵" required>
            </div>
            <div>
                <label for="newMapWidth" class="block mb-2 text-sm font-medium text-gray-300">가로 (px)</label>
                <input type="number" id="newMapWidth" class="w-full p-2.5 rounded bg-gray-700 border-gray-600" value="600">
            </div>
            <div>
                <label for="newMapHeight" class="block mb-2 text-sm font-medium text-gray-300">세로 (px)</label>
                <input type="number" id="newMapHeight" class="w-full p-2.5 rounded bg-gray-700 border-gray-600" value="900">
            </div>
            <div class="flex justify-end gap-2 mt-4">
                <button id="cancelNewMapBtn" class="bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded">취소</button>
                <button id="confirmNewMapBtn" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded">생성</button>
            </div>
        </div>
    </div>
    <div id="renameMapModal" class="modal">
        <div class="modal-content flex flex-col gap-4">
            <h2 class="text-xl font-bold text-white">맵 이름 변경</h2>
            <input type="text" id="renameMapInput" class="w-full p-2.5 rounded bg-gray-700 border-gray-600 text-white">
            <div class="flex justify-end gap-2 mt-4">
                <button id="cancelRenameBtn" class="bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded">취소</button>
                <button id="confirmRenameBtn" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded">변경</button>
            </div>
        </div>
    </div>
    <div id="deleteConfirmModal" class="modal">
        <div class="modal-content flex flex-col gap-4">
            <h2 class="text-xl font-bold text-white">맵 삭제</h2>
            <p id="deleteConfirmText" class="text-gray-300"></p>
            <div class="flex justify-end gap-2 mt-4">
                <button id="cancelDeleteBtn" class="bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded">취소</button>
                <button id="confirmDeleteBtn" class="bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-4 rounded">삭제</button>
            </div>
        </div>
    </div>

    <div id="growingFieldModal" class="modal">
        <div class="modal-content flex flex-col gap-4">
            <h2 class="text-xl font-bold text-purple-400">성장형 자기장 설정 ⚙️</h2>
            <div class="flex items-center justify-between">
                <label for="fieldDirection">방향:</label>
                <select id="fieldDirection" class="p-2 rounded w-48">
                    <option value="RIGHT">오른쪽 →</option>
                    <option value="LEFT">왼쪽 ←</option>
                    <option value="DOWN" selected>아래 ↓</option>
                    <option value="UP">위 ↑</option>
                </select>
            </div>
            <div class="flex items-center justify-between">
                <label for="fieldSpeed">속도 (초/전체이동):</label>
                <input type="number" id="fieldSpeed" min="0.1" max="30" step="0.1" value="4" class="w-24 p-2 rounded">
            </div>
            <div class="flex items-center justify-between">
                <label for="fieldDelay">시작 지연(초):</label>
                <input type="number" id="fieldDelay" min="0" value="0" class="w-24 p-2 rounded">
            </div>
            <div class="flex justify-end gap-2 mt-4">
                <button id="growingFieldDefaultBtn" class="bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded">기본값</button>
                <button id="closeGrowingFieldModal" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded">저장</button>
            </div>
        </div>
    </div>
   
    <div id="autoFieldModal" class="modal">
        <div class="modal-content flex flex-col gap-4">
            <h2 class="text-xl font-bold text-purple-400">자동 자기장 설정 ⚙️</h2>
             <div class="flex items-center justify-between">
                <label class="toggle-label text-sm font-medium text-purple-400">
                    활성화
                    <input type="checkbox" id="autoFieldActiveToggle" class="toggle-input">
                    <span class="toggle-slider ml-2"></span>
                </label>
            </div>
             <div class="flex items-center justify-between">
                <label for="autoFieldShrinkTime">축소 시간(초):</label>
                <input type="number" id="autoFieldShrinkTime" min="1" value="60" class="w-24 p-2 rounded">
            </div>
            <div class="flex items-center justify-between">
                <label for="autoFieldSafeZoneSize">최종 크기(칸):</label>
                <input type="number" id="autoFieldSafeZoneSize" min="1" value="6" class="w-24 p-2 rounded">
            </div>
             <div class="flex justify-end gap-2 mt-4">
                <button id="autoFieldDefaultBtn" class="bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded">기본값</button>
                <button id="closeAutoFieldModal" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded">저장</button>
            </div>
        </div>
    </div>

    <div id="hadokenModal" class="modal">
        <div class="modal-content flex flex-col gap-4">
            <h2 class="text-xl font-bold text-indigo-400">장풍 설정 ⚙️</h2>
            <div class="flex items-center justify-between">
                <label for="hadokenKnockback">넉백 거리: <span id="hadokenKnockbackValue">15</span></label>
                <input type="range" id="hadokenKnockback" min="0" max="50" value="15" class="w-48">
            </div>
             <div class="flex justify-end gap-2 mt-4">
                <button id="hadokenDefaultBtn" class="bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded">기본값</button>
                <button id="closeHadokenModal" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded">저장</button>
            </div>
        </div>
    </div>

    <script type="module">
        // Firebase SDKs import
        import { initializeApp } from "https://www.gstatic.com/firebasejs/10.9.0/firebase-app.js";
        import { getAuth, signInAnonymously, onAuthStateChanged, GoogleAuthProvider, signInWithPopup, signOut } from "https://www.gstatic.com/firebasejs/10.9.0/firebase-auth.js";
        import { getFirestore, collection, doc, getDoc, getDocs, setDoc, deleteDoc, writeBatch } from "https://www.gstatic.com/firebasejs/10.9.0/firebase-firestore.js";

        // Your web app's Firebase configuration
        const firebaseConfig = {
          apiKey: "AIzaSyDCB9bou34n3nKntyDbCIV-s3ccifgwI-k",
          authDomain: "battle-simulation-42512.firebaseapp.com",
          projectId: "battle-simulation-42512",
          storageBucket: "battle-simulation-42512.firebasestorage.app",
          messagingSenderId: "705586780455",
          appId: "1:705586780455:web:9e485767a508082a0bb102"
        };

        // Initialize Firebase
        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getFirestore(app);
        const provider = new GoogleAuthProvider();
        let currentUser = null;
        let gameManager = null; // Declare gameManager in the higher scope

        // --- UI Elements for Auth ---
        const loadingStatus = document.getElementById('loadingStatus');
        const googleLoginBtn = document.getElementById('googleLoginBtn');
        const userDetails = document.getElementById('userDetails');
        const userPhoto = document.getElementById('userPhoto');
        const userName = document.getElementById('userName');
        const logoutBtn = document.getElementById('logoutBtn');

        // --- Auth Event Handlers ---
        googleLoginBtn.addEventListener('click', () => {
            signInWithPopup(auth, provider).catch(error => {
                console.error("Google sign-in error", error);
            });
        });

        logoutBtn.addEventListener('click', () => {
            signOut(auth);
        });

        // Firebase Authentication State Change Listener
        onAuthStateChanged(auth, (user) => {
            if (user) {
                currentUser = user;
                loadingStatus.style.display = 'none';

                if (user.isAnonymous) {
                    googleLoginBtn.style.display = 'flex';
                    userDetails.style.display = 'none';
                } else {
                    googleLoginBtn.style.display = 'none';
                    userDetails.style.display = 'flex';
                    userPhoto.src = user.photoURL;
                    userName.textContent = user.displayName;
                }
                document.getElementById('addNewMapCard').classList.remove('hidden');
                if (gameManager && gameManager.state === 'HOME') {
                     gameManager.init();
                }
            } else {
                // No user is signed in.
                currentUser = null;
                userDetails.style.display = 'none';
                googleLoginBtn.style.display = 'flex';
                loadingStatus.style.display = 'none';
                // Clear map grid if user logs out
                const mapGrid = document.getElementById('mapGrid');
                const addNewMapCard = document.getElementById('addNewMapCard');
                while (mapGrid.firstChild && mapGrid.firstChild !== addNewMapCard) {
                    mapGrid.removeChild(mapGrid.firstChild);
                }
                addNewMapCard.classList.add('hidden');

                signInAnonymously(auth).catch((error) => {
                    console.error("Anonymous sign-in failed:", error);
                    loadingStatus.textContent = '로그인에 실패했습니다. 새로고침 해주세요.';
                    loadingStatus.style.display = 'block';
                });
            }
        });


        document.addEventListener('DOMContentLoaded', () => {
            // --- 화면 및 모달 요소 ---
            const homeScreen = document.getElementById('homeScreen');
            const editorScreen = document.getElementById('editorScreen');
            const mapGrid = document.getElementById('mapGrid');
            const addNewMapCard = document.getElementById('addNewMapCard');
            const newMapModal = document.getElementById('newMapModal');
            const renameMapModal = document.getElementById('renameMapModal');
            const deleteConfirmModal = document.getElementById('deleteConfirmModal');
            const mapSettingsModal = document.getElementById('mapSettingsModal');
            const closeMapSettingsModal = document.getElementById('closeMapSettingsModal');
            const mapSettingsBtn = document.getElementById('mapSettingsBtn');
            const killSoundToggle = document.getElementById('killSoundToggle');
           
            // --- 기본 요소 및 상수 설정 ---
            const canvas = document.getElementById('gameCanvas');
            const ctx = canvas.getContext('2d');
            const toolbox = document.getElementById('toolbox');
            const simStartBtn = document.getElementById('simStartBtn');
            const simPauseBtn = document.getElementById('simPauseBtn');
            const simPlayBtn = document.getElementById('simPlayBtn');
            const simPlacementResetBtn = document.getElementById('simPlacementResetBtn');
            const simResetBtn = document.getElementById('simResetBtn');
            const resizeBtn = document.getElementById('resizeBtn');
            const widthInput = document.getElementById('widthInput');
            const heightInput = document.getElementById('heightInput');
            const statusText = document.getElementById('statusText');
            const actionCamToggle = document.getElementById('actionCamToggle');
            const backToHomeBtn = document.getElementById('backToHomeBtn');
            const saveMapBtn = document.getElementById('saveMapBtn');
            const muteBtn = document.getElementById('muteBtn');
           
            const growingFieldSettingsBtn = document.getElementById('growingFieldSettingsBtn');
            const growingFieldModal = document.getElementById('growingFieldModal');
            const closeGrowingFieldModal = document.getElementById('closeGrowingFieldModal');
            const autoFieldSettingsBtn = document.getElementById('autoFieldSettingsBtn');
            const autoFieldModal = document.getElementById('autoFieldModal');
            const closeAutoFieldModal = document.getElementById('closeAutoFieldModal');
            const hadokenSettingsBtn = document.getElementById('hadokenSettingsBtn');
            const hadokenModal = document.getElementById('hadokenModal');
            const closeHadokenModal = document.getElementById('closeHadokenModal');
            const hadokenKnockbackSlider = document.getElementById('hadokenKnockback');
            const hadokenKnockbackValue = document.getElementById('hadokenKnockbackValue');
            const growingFieldDefaultBtn = document.getElementById('growingFieldDefaultBtn');
            const autoFieldDefaultBtn = document.getElementById('autoFieldDefaultBtn');
            const hadokenDefaultBtn = document.getElementById('hadokenDefaultBtn');

            const GRID_SIZE = 20;
            let COLS, ROWS;

            const TILE = { FLOOR: 0, WALL: 1, CRACKED_WALL: 2, LAVA: 3, TELEPORTER: 4, HEAL_PACK: 5, REPLICATION_TILE: 6 };
            const TEAM = { A: 'A', B: 'B', C: 'C', D: 'D' };

            const COLORS = {
                FLOOR: '#4a5568', WALL: '#2d3748',
                TEAM_A: '#ef4444', TEAM_B: '#3b82f6',
                TEAM_C: '#22c55e', TEAM_D: '#eab308',
                GRID: '#374151',
                CRACKED_WALL: '#44403c', LAVA: '#f97316',
                TELEPORTER: '#a855f7', HEAL_PACK: '#22c55e',
                REPLICATION_TILE: '#f59e0b',
                MAGNETIC_FIELD: '#a855f7'
            };

            // --- 오디오 관리자 클래스 ---
            class AudioManager {
                constructor() {
                    this.isInitialized = false;
                    this.isMuted = false;
                    this.isKillSoundEnabled = true;

                    const soundFiles = {
                        replication: './sounds/2+.mp3',
                        arrowShoot: './sounds/arrow.mp3',
                        crackedWallBreak: './sounds/boxcrash.mp3',
                        dualSwordHit: './sounds/double%20sword.mp3',
                        equip: './sounds/equip.mp3',
                        fireball: './sounds/fireball.mp3',
                        heal: './sounds/heal.mp3',
                        unitDeath: './sounds/kill.mp3',
                        hadokenCast: './sounds/long%20wind.mp3',
                        nexusDestruction: './sounds/Nexus%20destruction.mp3',
                        punch: './sounds/punch.mp3',
                        shurikenShoot: './sounds/shuriken.mp3',
                        swordHit: './sounds/sword.mp3',
                        teleport: './sounds/teleport.mp3',
                        arrowHit: './sounds/arrow.mp3',
                        hadokenHit: './sounds/punch.mp3',
                    };


                    this.players = {};
                    for (const key in soundFiles) {
                        if (typeof soundFiles[key] === 'string' && soundFiles[key].length > 0) {
                             this.players[key] = new Tone.Player(soundFiles[key]).toDestination();
                        }
                    }
                }

                async init() {
                    if (this.isInitialized) return;
                    try {
                        await Tone.start();
                        this.isInitialized = true;
                        console.log("Audio Initialized.");
                    } catch (e) {
                        console.error("Could not start audio context:", e);
                    }
                }

                play(sound) {
                    if (!this.isInitialized || this.isMuted || !this.players[sound]) return;
                   
                    if (sound === 'unitDeath' && !this.isKillSoundEnabled) {
                        return;
                    }

                    const player = this.players[sound];
                    if (player.loaded) {
                        player.start();
                    } else {
                        if (player.buffer && player.buffer.url) {
                            player.load(player.buffer.url).then(() => {
                                if (!this.isMuted) player.start();
                            }).catch(e => console.error(`Error loading sound: ${sound}`, e));
                        }
                    }
                }

                toggleMute() {
                    this.isMuted = !this.isMuted;
                    document.getElementById('soundOnIcon').classList.toggle('hidden', this.isMuted);
                    document.getElementById('soundOffIcon').classList.toggle('hidden', !this.isMuted);
                    return this.isMuted;
                }

                toggleKillSound(isEnabled) {
                    this.isKillSoundEnabled = isEnabled;
                    localStorage.setItem('arenaKillSoundEnabled', isEnabled);
                }
            }
            const audioManager = new AudioManager();

            // --- 클래스 정의 ---
           
            // 성장형 자기장 클래스
            class GrowingMagneticField {
                constructor(id, x, y, width, height, settings) {
                    this.id = id;
                    this.gridX = x; this.gridY = y;
                    this.width = width; this.height = height;
                   
                    this.direction = settings.direction;
                    this.totalFrames = settings.speed * 60;
                    this.delay = settings.delay * 60;
                   
                    this.delayTimer = 0;
                    this.animationTimer = 0;
                    this.progress = 0;
                }

                update() {
                    if (this.delayTimer < this.delay) {
                        this.delayTimer++;
                        return;
                    }
                    if (this.animationTimer < this.totalFrames) {
                        this.animationTimer++;
                    }
                    const linearProgress = this.animationTimer / this.totalFrames;
                    this.progress = -(Math.cos(Math.PI * linearProgress) - 1) / 2;
                }

                draw() {
                    const startX = this.gridX * GRID_SIZE;
                    const startY = this.gridY * GRID_SIZE;
                    const totalWidth = this.width * GRID_SIZE;
                    const totalHeight = this.height * GRID_SIZE;
                   
                    if (gameManager.state === 'EDIT') {
                        ctx.fillStyle = 'rgba(168, 85, 247, 0.2)';
                        ctx.fillRect(startX, startY, totalWidth, totalHeight);
                        ctx.strokeStyle = 'rgba(168, 85, 247, 0.6)';
                        ctx.strokeRect(startX, startY, totalWidth, totalHeight);

                        const centerX = startX + totalWidth / 2;
                        const centerY = startY + totalHeight / 2;
                       
                        ctx.save();
                        ctx.translate(centerX, centerY);
                       
                        let angle = 0;
                        switch(this.direction) {
                            case 'RIGHT': angle = 0; break;
                            case 'LEFT':  angle = Math.PI; break;
                            case 'DOWN':  angle = Math.PI / 2; break;
                            case 'UP':    angle = -Math.PI / 2; break;
                        }
                        ctx.rotate(angle);

                        const arrowLength = Math.min(totalWidth, totalHeight) * 0.4;
                        const headSize = Math.min(arrowLength * 0.5, GRID_SIZE * 1.5);
                        const bodyWidth = headSize * 0.4;

                        ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                        ctx.strokeStyle = 'rgba(255, 255, 255, 0.6)';
                        ctx.lineWidth = 2;

                        ctx.beginPath();
                        ctx.moveTo(-arrowLength / 2, -bodyWidth / 2);
                        ctx.lineTo(arrowLength / 2 - headSize, -bodyWidth / 2);
                        ctx.lineTo(arrowLength / 2 - headSize, -headSize / 2);
                        ctx.lineTo(arrowLength / 2, 0);
                        ctx.lineTo(arrowLength / 2 - headSize, headSize / 2);
                        ctx.lineTo(arrowLength / 2 - headSize, bodyWidth / 2);
                        ctx.lineTo(-arrowLength / 2, bodyWidth / 2);
                        ctx.closePath();
                        ctx.fill();
                        ctx.stroke();

                        ctx.restore();
                    }
                }
            }


            // 넥서스 클래스
            class Nexus {
                constructor(x, y, team) {
                    this.gridX = x; this.gridY = y;
                    this.pixelX = x * GRID_SIZE + GRID_SIZE / 2;
                    this.pixelY = y * GRID_SIZE + GRID_SIZE / 2;
                    this.team = team;
                    this.hp = 500;
                    this.maxHp = 500;
                    this.isDestroying = false;
                    this.explosionParticles = [];
                }
                takeDamage(damage) {
                    if (this.isDestroying) return;
                    this.hp -= damage;
                    if (this.hp <= 0) {
                        this.hp = 0;
                        this.isDestroying = true;
                        this.createExplosion();
                        audioManager.play('nexusDestruction');
                    }
                }
                createExplosion() {
                    for (let i = 0; i < 60; i++) {
                        this.explosionParticles.push({
                            x: this.pixelX, y: this.pixelY,
                            angle: Math.random() * Math.PI * 2,
                            speed: Math.random() * 6 + 2,
                            radius: Math.random() * 5 + 2,
                            lifespan: 80,
                            color: ['#ffcc00', '#ff9900', '#ff6600', '#666666', '#ef4444'][Math.floor(Math.random() * 5)]
                        });
                    }
                }
                update() {
                    if (!this.isDestroying) return;
                    this.explosionParticles.forEach(p => {
                        p.x += Math.cos(p.angle) * p.speed;
                        p.y += Math.sin(p.angle) * p.speed;
                        p.lifespan -= 1;
                        p.speed *= 0.97;
                    });
                    this.explosionParticles = this.explosionParticles.filter(p => p.lifespan > 0);
                }
                draw() {
                    if (this.isDestroying) {
                        this.drawExplosion();
                    } else {
                        ctx.save();
                        ctx.translate(this.pixelX, this.pixelY);
                        switch(this.team) {
                            case TEAM.A: ctx.fillStyle = COLORS.TEAM_A; break;
                            case TEAM.B: ctx.fillStyle = COLORS.TEAM_B; break;
                            case TEAM.C: ctx.fillStyle = COLORS.TEAM_C; break;
                            case TEAM.D: ctx.fillStyle = COLORS.TEAM_D; break;
                        }
                        ctx.strokeStyle = 'black'; ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.moveTo(0, -GRID_SIZE * 0.8); ctx.lineTo(GRID_SIZE * 0.7, 0);
                        ctx.lineTo(0, GRID_SIZE * 0.8); ctx.lineTo(-GRID_SIZE * 0.7, 0);
                        ctx.closePath(); ctx.fill(); ctx.stroke();
                        const hpBarWidth = GRID_SIZE * 1.5;
                        const hpBarX = -hpBarWidth / 2;
                        const hpBarY = -GRID_SIZE * 1.2;
                        ctx.fillStyle = '#111827'; ctx.fillRect(hpBarX, hpBarY, hpBarWidth, 8);
                        ctx.fillStyle = '#facc15'; ctx.fillRect(hpBarX, hpBarY, hpBarWidth * (this.hp / this.maxHp), 8);
                        ctx.restore();
                    }
                }
                drawExplosion() {
                    this.explosionParticles.forEach(p => {
                        ctx.globalAlpha = p.lifespan / 80;
                        ctx.fillStyle = p.color;
                        ctx.beginPath(); ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2); ctx.fill();
                    });
                    ctx.globalAlpha = 1.0;
                }
            }

            // 발사체 클래스
            class Projectile {
                constructor(owner, target, type = 'arrow') {
                    this.owner = owner; this.pixelX = owner.pixelX; this.pixelY = owner.pixelY;
                    this.type = type;
                   
                    if (type === 'hadoken') this.speed = 4;
                    else if (type === 'shuriken') this.speed = 2;
                    else this.speed = 6;

                    this.damage = owner.attackPower;
                    this.knockback = (type === 'hadoken') ? gameManager.hadokenKnockback : 0;
                    const inaccuracy = (type === 'shuriken') ? 0 : GRID_SIZE * 0.8;
                    const targetX = target.pixelX + (Math.random() - 0.5) * inaccuracy;
                    const targetY = target.pixelY + (Math.random() - 0.5) * inaccuracy;
                    const dx = targetX - this.pixelX; const dy = targetY - this.pixelY;
                    this.angle = Math.atan2(dy, dx);
                    this.destroyed = false;
                    this.trail = [];
                    this.rotationAngle = 0;
                }
                update() {
                    if (this.type === 'hadoken') {
                        this.trail.push({x: this.pixelX, y: this.pixelY});
                        if (this.trail.length > 10) this.trail.shift();
                    }
                    if (this.type === 'shuriken') {
                        this.rotationAngle += 0.4 * gameManager.gameSpeed;
                    }

                    const nextX = this.pixelX + Math.cos(this.angle) * gameManager.gameSpeed * this.speed;
                    const nextY = this.pixelY + Math.sin(this.angle) * gameManager.gameSpeed * this.speed;
                    const gridX = Math.floor(nextX / GRID_SIZE);
                    const gridY = Math.floor(nextY / GRID_SIZE);

                    if (gridY >= 0 && gridY < ROWS && gridX >= 0 && gridX < COLS) {
                        const tile = gameManager.map[gridY][gridX];
                        if (tile.type === TILE.WALL || tile.type === TILE.CRACKED_WALL) {
                            if (tile.type === TILE.CRACKED_WALL) {
                                gameManager.damageTile(gridX, gridY, this.damage);
                            }
                            this.destroyed = true;
                            return;
                        }
                    }
                    this.pixelX = nextX; this.pixelY = nextY;
                }
                draw() {
                    if (this.type === 'arrow') {
                        ctx.save(); ctx.translate(this.pixelX, this.pixelY); ctx.rotate(this.angle);
                        ctx.fillStyle = '#a16207';
                        ctx.fillRect(-GRID_SIZE * 0.6, -1, GRID_SIZE * 0.6, 2);
                        ctx.strokeRect(-GRID_SIZE * 0.6, -1, GRID_SIZE * 0.6, 2);
                        ctx.fillStyle = '#e5e7eb';
                        ctx.beginPath(); ctx.moveTo(0, 0); ctx.lineTo(-4, -3); ctx.lineTo(-4, 3); ctx.closePath(); ctx.fill();
                        ctx.fillStyle = '#d1d5db';
                        ctx.beginPath();
                        ctx.moveTo(-GRID_SIZE * 0.6, -1); ctx.lineTo(-GRID_SIZE * 0.7, -3);
                        ctx.lineTo(-GRID_SIZE * 0.5, -1); ctx.closePath();
                        ctx.fill()
                        ctx.beginPath();
                        ctx.moveTo(-GRID_SIZE * 0.6, 1); ctx.lineTo(-GRID_SIZE * 0.7, 3);
                        ctx.lineTo(-GRID_SIZE * 0.5, 1); ctx.closePath();
                        ctx.fill()
                        ctx.restore();
                    } else if (this.type === 'hadoken') {
                        // Draw trail
                        for (let i = 0; i < this.trail.length; i++) {
                            const pos = this.trail[i];
                            const alpha = (i / this.trail.length) * 0.5;
                            ctx.fillStyle = `rgba(139, 92, 246, ${alpha})`;
                            ctx.beginPath();
                            ctx.arc(pos.x, pos.y, (GRID_SIZE / 2) * (i / this.trail.length), 0, Math.PI * 2);
                            ctx.fill();
                        }
                        // Draw main projectile
                        ctx.fillStyle = '#c4b5fd';
                        ctx.beginPath();
                        ctx.arc(this.pixelX, this.pixelY, GRID_SIZE / 2, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.fillStyle = '#8b5cf6';
                        ctx.beginPath();
                        ctx.arc(this.pixelX, this.pixelY, GRID_SIZE / 3, 0, Math.PI * 2);
                        ctx.fill();
                    } else if (this.type === 'shuriken') {
                        ctx.save();
                        ctx.translate(this.pixelX, this.pixelY);
                        ctx.rotate(this.rotationAngle);
                        const scale = 0.6;
                        ctx.scale(scale, scale);
                        ctx.fillStyle = '#4a5568';
                        ctx.strokeStyle = 'black';
                        ctx.lineWidth = 2 / scale;

                        ctx.beginPath();
                        ctx.moveTo(0, -GRID_SIZE * 0.8);
                        ctx.lineTo(GRID_SIZE * 0.2, -GRID_SIZE * 0.2);
                        ctx.lineTo(GRID_SIZE * 0.8, 0);
                        ctx.lineTo(GRID_SIZE * 0.2, GRID_SIZE * 0.2);
                        ctx.lineTo(0, GRID_SIZE * 0.8);
                        ctx.lineTo(-GRID_SIZE * 0.2, GRID_SIZE * 0.2);
                        ctx.lineTo(-GRID_SIZE * 0.8, 0);
                        ctx.lineTo(-GRID_SIZE * 0.2, -GRID_SIZE * 0.2);
                        ctx.closePath();
                        ctx.fill();
                        ctx.stroke();

                        ctx.fillStyle = '#6b7280';
                        ctx.beginPath();
                        ctx.arc(0, 0, GRID_SIZE * 0.2, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.stroke();
                        ctx.restore();
                    }
                }
            }

            // 광역 효과 클래스
            class AreaEffect {
                constructor(x, y, type) {
                    this.pixelX = x; this.pixelY = y; this.type = type;
                    this.duration = 30; this.maxRadius = GRID_SIZE * 2.5; this.currentRadius = 0;
                }
                update() { this.duration -= gameManager.gameSpeed; this.currentRadius = this.maxRadius * (1 - (this.duration / 30)); }
                draw() {
                    if (this.type === 'fire_pillar') {
                        const opacity = this.duration / 30;
                        ctx.fillStyle = `rgba(255, 165, 0, ${opacity * 0.5})`;
                        ctx.beginPath(); ctx.arc(this.pixelX, this.pixelY, this.currentRadius, 0, Math.PI * 2); ctx.fill();
                        ctx.fillStyle = `rgba(255, 69, 0, ${opacity * 0.7})`;
                        ctx.beginPath(); ctx.arc(this.pixelX, this.pixelY, this.currentRadius * 0.6, 0, Math.PI * 2); ctx.fill();
                    }
                }
            }

            // 시각 효과 클래스
            class Effect {
                constructor(x, y, type, target) {
                    this.x = x; this.y = y; this.type = type; this.target = target;
                    this.duration = 20; this.angle = Math.random() * Math.PI * 2;
                }
                update() { this.duration -= gameManager.gameSpeed; }
                draw() {
                    if (this.type === 'slash' || this.type === 'dual_sword_slash') {
                        ctx.save();
                        ctx.translate(this.target.pixelX, this.target.pixelY);
                        ctx.rotate(this.angle);
                        ctx.strokeStyle = `rgba(220, 38, 38, ${this.duration / 20})`;
                        ctx.lineWidth = this.type === 'slash' ? 3 : 2;
                        const arcSize = this.type === 'slash' ? GRID_SIZE : GRID_SIZE * 0.7;
                        ctx.beginPath();
                        ctx.arc(0, 0, arcSize, -0.5, 0.5);
                        ctx.stroke();
                        ctx.restore();
                    }
                }
            }

            // 무기 클래스
            class Weapon {
                constructor(x, y, type) {
                    this.gridX = x; this.gridY = y;
                    this.pixelX = x * GRID_SIZE + GRID_SIZE / 2;
                    this.pixelY = y * GRID_SIZE + GRID_SIZE / 2;
                    this.type = type;
                    this.isEquipped = false;
                }
                draw() {
                    if (this.isEquipped) return;
                    const centerX = this.pixelX; const centerY = this.pixelY;
                    const scale = (this.type === 'crown') ? 1.0 : 0.8;
                    ctx.save(); ctx.translate(centerX, centerY); ctx.scale(scale, scale);
                    ctx.strokeStyle = 'black'; ctx.lineWidth = 1 / scale;

                    if (this.type === 'sword') {
                        ctx.rotate(Math.PI / 4);
                        const bladeGradient = ctx.createLinearGradient(0, -GRID_SIZE, 0, 0);
                        bladeGradient.addColorStop(0, '#f3f4f6'); bladeGradient.addColorStop(1, '#9ca3af');
                        ctx.fillStyle = bladeGradient;
                        ctx.beginPath();
                        ctx.moveTo(-2, GRID_SIZE * 0.3); ctx.lineTo(-2, -GRID_SIZE * 1.0);
                        ctx.lineTo(0, -GRID_SIZE * 1.2); ctx.lineTo(2, -GRID_SIZE * 1.0);
                        ctx.lineTo(2, GRID_SIZE * 0.3);
                        ctx.closePath(); ctx.fill(); ctx.stroke();
                        ctx.fillStyle = '#374151';
                        ctx.beginPath();
                        ctx.moveTo(-GRID_SIZE * 0.4, GRID_SIZE * 0.3); ctx.lineTo(GRID_SIZE * 0.4, GRID_SIZE * 0.3);
                        ctx.lineTo(GRID_SIZE * 0.5, GRID_SIZE * 0.3 + 3); ctx.lineTo(-GRID_SIZE * 0.5, GRID_SIZE * 0.3 + 3);
                        ctx.closePath(); ctx.fill(); ctx.stroke();
                        ctx.fillStyle = '#1f2937';
                        ctx.fillRect(-1.5, GRID_SIZE * 0.3 + 3, 3, GRID_SIZE * 0.3); ctx.strokeRect(-1.5, GRID_SIZE * 0.3 + 3, 3, GRID_SIZE * 0.3);
                    } else if (this.type === 'bow') {
                        ctx.rotate(Math.PI / 4);
                        ctx.fillStyle = '#f3f4f6';
                        ctx.fillRect(-GRID_SIZE * 0.7, -1, GRID_SIZE * 1.2, 2);
                        ctx.strokeRect(-GRID_SIZE * 0.7, -1, GRID_SIZE * 1.2, 2);
                        ctx.fillStyle = '#e5e7eb';
                        ctx.beginPath(); ctx.moveTo(GRID_SIZE * 0.5, 0); ctx.lineTo(GRID_SIZE * 0.3, -3); ctx.lineTo(GRID_SIZE * 0.3, 3); ctx.closePath(); ctx.fill();
                        ctx.fillStyle = '#d1d5db';
                        ctx.beginPath(); ctx.moveTo(-GRID_SIZE * 0.6, -1); ctx.lineTo(-GRID_SIZE * 0.7, -4); ctx.lineTo(-GRID_SIZE * 0.5, -1); ctx.closePath(); ctx.fill()
                        ctx.beginPath(); ctx.moveTo(-GRID_SIZE * 0.6, 1); ctx.lineTo(-GRID_SIZE * 0.7, 4); ctx.lineTo(-GRID_SIZE * 0.5, 1); ctx.closePath(); ctx.fill()
                        ctx.strokeStyle = 'black'; ctx.lineWidth = 6 / scale; ctx.beginPath(); ctx.arc(0, 0, GRID_SIZE * 0.8, -Math.PI / 2.2, Math.PI / 2.2); ctx.stroke();
                        ctx.strokeStyle = '#854d0e'; ctx.lineWidth = 4 / scale; ctx.beginPath(); ctx.arc(0, 0, GRID_SIZE * 0.8, -Math.PI / 2.2, Math.PI / 2.2); ctx.stroke();
                        ctx.strokeStyle = '#e5e7eb'; ctx.lineWidth = 1.5 / scale; ctx.beginPath();
                        const arcRadius = GRID_SIZE * 0.8, arcAngle = Math.PI / 2.2;
                        ctx.moveTo(Math.cos(-arcAngle) * arcRadius, Math.sin(-arcAngle) * arcRadius);
                        ctx.lineTo(-GRID_SIZE * 0.4, 0);
                        ctx.lineTo(Math.cos(arcAngle) * arcRadius, Math.sin(arcAngle) * arcRadius); ctx.stroke();
                    } else if (this.type === 'dual_swords') {
                        const drawCurvedSword = (rotation) => {
                            ctx.save();
                            ctx.rotate(rotation);
                            ctx.fillStyle = '#374151';
                            ctx.fillRect(-GRID_SIZE * 0.1, GRID_SIZE * 0.3, GRID_SIZE * 0.2, GRID_SIZE * 0.3);
                            ctx.strokeRect(-GRID_SIZE * 0.1, GRID_SIZE * 0.3, GRID_SIZE * 0.2, GRID_SIZE * 0.3);
                            ctx.beginPath();
                            ctx.moveTo(-GRID_SIZE * 0.3, GRID_SIZE * 0.3); ctx.lineTo(GRID_SIZE * 0.3, GRID_SIZE * 0.3);
                            ctx.lineTo(GRID_SIZE * 0.3, GRID_SIZE * 0.2); ctx.lineTo(-GRID_SIZE * 0.3, GRID_SIZE * 0.2);
                            ctx.closePath(); ctx.fill(); ctx.stroke();
                            const bladeGradient = ctx.createLinearGradient(0, -GRID_SIZE, 0, 0);
                            bladeGradient.addColorStop(0, '#f3f4f6'); bladeGradient.addColorStop(0.5, '#9ca3af'); bladeGradient.addColorStop(1, '#4b5563');
                            ctx.fillStyle = bladeGradient;
                            ctx.beginPath();
                            ctx.moveTo(0, GRID_SIZE * 0.2);
                            ctx.quadraticCurveTo(GRID_SIZE * 0.5, -GRID_SIZE * 0.4, 0, -GRID_SIZE * 0.9);
                            ctx.quadraticCurveTo(-GRID_SIZE * 0.1, -GRID_SIZE * 0.4, 0, GRID_SIZE * 0.2);
                            ctx.closePath(); ctx.fill(); ctx.stroke();
                            ctx.restore();
                        };
                        drawCurvedSword(-Math.PI / 4);
                        drawCurvedSword(Math.PI / 4);
                    } else if (this.type === 'staff') {
                        ctx.rotate(Math.PI / 4);
                        ctx.fillStyle = '#a16207'; ctx.fillRect(-2, -GRID_SIZE * 0.6, 4, GRID_SIZE * 1.2); ctx.strokeRect(-2, -GRID_SIZE * 0.6, 4, GRID_SIZE * 1.2);
                        ctx.fillStyle = '#a855f7'; ctx.beginPath(); ctx.arc(0, -GRID_SIZE * 0.7, GRID_SIZE * 0.25, 0, Math.PI * 2); ctx.fill(); ctx.stroke();
                    } else if (this.type === 'hadoken') {
                        ctx.rotate(Math.PI / 4);
                        const grad = ctx.createRadialGradient(0, 0, 1, 0, 0, GRID_SIZE * 1.2);
                        grad.addColorStop(0, '#bfdbfe');
                        grad.addColorStop(0.6, '#3b82f6');
                        grad.addColorStop(1, '#1e40af');
                        ctx.fillStyle = grad;
                        ctx.strokeStyle = 'black';
                        ctx.lineWidth = 1.5 / scale;
                        ctx.beginPath();
                        ctx.arc(-GRID_SIZE * 0.2, 0, GRID_SIZE * 0.6, Math.PI / 2, -Math.PI / 2, false);
                        ctx.lineTo(GRID_SIZE * 0.8, 0);
                        ctx.closePath();
                        ctx.fill();
                        ctx.stroke();
                    } else if (this.type === 'shuriken') {
                        ctx.rotate(Math.PI / 4);
                        ctx.fillStyle = '#4a5568';
                        ctx.strokeStyle = 'black';
                        ctx.lineWidth = 2 / scale;

                        ctx.beginPath();
                        ctx.moveTo(0, -GRID_SIZE * 0.8);
                        ctx.lineTo(GRID_SIZE * 0.2, -GRID_SIZE * 0.2);
                        ctx.lineTo(GRID_SIZE * 0.8, 0);
                        ctx.lineTo(GRID_SIZE * 0.2, GRID_SIZE * 0.2);
                        ctx.lineTo(0, GRID_SIZE * 0.8);
                        ctx.lineTo(-GRID_SIZE * 0.2, GRID_SIZE * 0.2);
                        ctx.lineTo(-GRID_SIZE * 0.8, 0);
                        ctx.lineTo(-GRID_SIZE * 0.2, -GRID_SIZE * 0.2);
                        ctx.closePath();
                        ctx.fill();
                        ctx.stroke();

                        ctx.fillStyle = '#6b7280';
                        ctx.beginPath();
                        ctx.arc(0, 0, GRID_SIZE * 0.2, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.stroke();
                    } else if (this.type === 'crown') {
                        ctx.fillStyle = '#facc15';
                        ctx.beginPath();
                        ctx.moveTo(-GRID_SIZE * 0.6, -GRID_SIZE * 0.25); ctx.lineTo(-GRID_SIZE * 0.6, GRID_SIZE * 0.35);
                        ctx.lineTo(GRID_SIZE * 0.6, GRID_SIZE * 0.35); ctx.lineTo(GRID_SIZE * 0.6, -GRID_SIZE * 0.25);
                        ctx.lineTo(GRID_SIZE * 0.3, 0); ctx.lineTo(0, -GRID_SIZE * 0.25);
                        ctx.lineTo(-GRID_SIZE * 0.3, 0); ctx.closePath();
                        ctx.fill(); ctx.stroke();
                    }
                    ctx.restore();
                }
            }

            // 유닛 클래스
            class Unit {
                constructor(x, y, team) {
                    this.gridX = x; this.gridY = y;
                    this.pixelX = x * GRID_SIZE + GRID_SIZE / 2;
                    this.pixelY = y * GRID_SIZE + GRID_SIZE / 2;
                    this.team = team; this.hp = 100;
                    this.baseSpeed = 1.0; this.facingAngle = Math.random() * Math.PI * 2;
                    this.baseAttackPower = 5; this.baseAttackRange = 1.5 * GRID_SIZE;
                    this.baseDetectionRange = 6 * GRID_SIZE;
                    this.attackCooldown = 0; this.baseCooldownTime = 80;
                    this.state = 'IDLE'; this.alertedCounter = 0;
                    this.weapon = null; this.target = null; this.moveTarget = null;
                    this.isCasting = false; this.castingProgress = 0; this.castTargetPos = null;
                    this.castDuration = 120; // 2초
                    this.teleportCooldown = 0;
                    this.isKing = false; this.spawnCooldown = 0; this.spawnInterval = 420;
                    this.knockbackX = 0; this.knockbackY = 0;
                    this.isInMagneticField = false;
                    this.evasionCooldown = 0; // 표창 유닛 회피 쿨다운
                }
               
                get speed() {
                    let speedModifier = 0;
                    if (this.isInMagneticField) speedModifier = -0.7;

                    const gridX = Math.floor(this.pixelX / GRID_SIZE);
                    const gridY = Math.floor(this.pixelY / GRID_SIZE);
                    if (gridY >= 0 && gridY < ROWS && gridX >= 0 && gridX < COLS) {
                        const tile = gameManager.map[gridY][gridX];
                        if (tile.type === TILE.LAVA) speedModifier = -0.5;
                    }
                   
                    let combatSpeedBoost = 0;
                    if (this.weapon && this.weapon.type === 'dual_swords' && (this.state === 'AGGRESSIVE' || this.state === 'ATTACKING_NEXUS')) {
                        combatSpeedBoost = 0.5;
                    }
                    const finalSpeed = (this.baseSpeed + (this.weapon ? this.weapon.speedBonus || 0 : 0) + combatSpeedBoost) + speedModifier;
                    return Math.max(0.1, finalSpeed); // 최소 속도 보장
                }
                get attackPower() { return this.baseAttackPower + (this.weapon ? this.weapon.attackPowerBonus || 0 : 0); }
                get attackRange() { return this.baseAttackRange + (this.weapon ? this.weapon.attackRangeBonus || 0 : 0); }
                get detectionRange() { return this.baseDetectionRange + (this.weapon ? this.weapon.detectionRangeBonus || 0 : 0); }
                get cooldownTime() { return this.baseCooldownTime + (this.weapon ? this.weapon.attackCooldownBonus || 0 : 0); }

                equipWeapon(weaponType, isClone = false) {
                    this.weapon = gameManager.createWeapon(0, 0, weaponType);
                    audioManager.play('equip');
                    if (this.weapon.type === 'crown' && !isClone) {
                        this.isKing = true;
                    }
                    this.state = 'IDLE';
                }

                findClosest(items) {
                    let closestItem = null, minDistance = Infinity;
                    for (const item of items) {
                        const distance = Math.hypot(this.pixelX - item.pixelX, this.pixelY - item.pixelY);
                        if (distance < minDistance) { minDistance = distance; closestItem = item; }
                    }
                    return {item: closestItem, distance: minDistance};
                }
               
                applyPhysics() {
                    let nextX = this.pixelX + this.knockbackX * gameManager.gameSpeed;
                    let nextY = this.pixelY + this.knockbackY * gameManager.gameSpeed;
                   
                    const nextGridX_kb = Math.floor(nextX / GRID_SIZE);
                    const nextGridY_kb = Math.floor(nextY / GRID_SIZE);
                    if (nextGridY_kb >= 0 && nextGridY_kb < ROWS && nextGridX_kb >= 0 && nextGridX_kb < COLS) {
                        const collidedTile = gameManager.map[nextGridY_kb][nextGridX_kb];
                         if (collidedTile.type === TILE.WALL || collidedTile.type === TILE.CRACKED_WALL) {
                            nextX = this.pixelX;
                            nextY = this.pixelY;
                            this.knockbackX = 0;
                            this.knockbackY = 0;
                        }
                    }

                    nextX = Math.max(0, Math.min(canvas.width, nextX));
                    nextY = Math.max(0, Math.min(canvas.height, nextY));

                    this.pixelX = nextX;
                    this.pixelY = nextY;

                    this.knockbackX *= 0.9;
                    this.knockbackY *= 0.9;
                    if (Math.abs(this.knockbackX) < 0.1) this.knockbackX = 0;
                    if (Math.abs(this.knockbackY) < 0.1) this.knockbackY = 0;
                }

                move() {
                    if (!this.moveTarget || this.isCasting) return;
                    const dx = this.moveTarget.x - this.pixelX, dy = this.moveTarget.y - this.pixelY;
                    const distance = Math.hypot(dx, dy);
                    const currentSpeed = this.speed * gameManager.gameSpeed;
                    if (distance < currentSpeed) {
                        this.pixelX = this.moveTarget.x; this.pixelY = this.moveTarget.y;
                        this.moveTarget = null; return;
                    }
                    const angle = Math.atan2(dy, dx);
                    const nextPixelX = this.pixelX + Math.cos(angle) * currentSpeed;
                    const nextPixelY = this.pixelY + Math.sin(angle) * currentSpeed;
                    const nextGridX = Math.floor(nextPixelX / GRID_SIZE);
                    const nextGridY = Math.floor(nextPixelY / GRID_SIZE);

                    if (nextGridY >= 0 && nextGridY < ROWS && nextGridX >= 0 && nextGridX < COLS) {
                        const collidedTile = gameManager.map[nextGridY][nextGridX];
                        if (collidedTile.type === TILE.WALL || collidedTile.type === TILE.CRACKED_WALL) {
                            if (collidedTile.type === TILE.CRACKED_WALL) {
                                gameManager.damageTile(nextGridX, nextGridY, 999);
                            }
                            const bounceAngle = this.facingAngle + Math.PI;
                            this.pixelX += Math.cos(bounceAngle) * 2;
                            this.pixelY += Math.sin(bounceAngle) * 2;
                            this.moveTarget = null;
                            return;
                        }
                    } else {
                        const bounceAngle = this.facingAngle + Math.PI;
                        this.pixelX += Math.cos(bounceAngle) * 2;
                        this.pixelY += Math.sin(bounceAngle) * 2;
                        this.moveTarget = null;
                        return;
                    }
                   
                    this.facingAngle = angle; this.pixelX = nextPixelX; this.pixelY = nextPixelY;
                }

                attack(target) {
                    if (!target || this.attackCooldown > 0) return;
                   
                    const currentAttackPower = this.attackPower;

                    if (this.weapon && this.weapon.type === 'staff') {
                        this.isCasting = true; this.castingProgress = 0; this.castTargetPos = { x: target.pixelX, y: target.pixelY }; this.target = target;
                        audioManager.play('fireball');
                    } else if (this.weapon && this.weapon.type === 'hadoken') {
                         this.isCasting = true; this.castingProgress = 0; this.castTargetPos = { x: target.pixelX, y: target.pixelY }; this.target = target;
                         audioManager.play('hadokenCast');
                    } else {
                        this.attackCooldown = this.cooldownTime;
                        const targetGridX = Math.floor(target.pixelX / GRID_SIZE);
                        const targetGridY = Math.floor(target.pixelY / GRID_SIZE);
                        if(targetGridY < 0 || targetGridY >= ROWS || targetGridX < 0 || targetGridX >= COLS) return;
                        const tile = gameManager.map[targetGridY][targetGridX];
                       
                        if (tile.type === TILE.CRACKED_WALL) {
                            gameManager.damageTile(targetGridX, targetGridY, currentAttackPower);
                        } else if (target instanceof Unit || target instanceof Nexus) {
                            if (this.weapon && this.weapon.type === 'sword') {
                                target.takeDamage(currentAttackPower); gameManager.createEffect('slash', this.pixelX, this.pixelY, target);
                                audioManager.play('swordHit');
                            } else if (this.weapon && this.weapon.type === 'bow') {
                                gameManager.createProjectile(this, target, 'arrow');
                                audioManager.play('arrowShoot');
                            } else if (this.weapon && this.weapon.type === 'dual_swords') {
                                target.takeDamage(currentAttackPower); gameManager.createEffect('dual_sword_slash', this.pixelX, this.pixelY, target);
                                audioManager.play('dualSwordHit');
                            } else if (this.weapon && this.weapon.type === 'shuriken') {
                                 gameManager.createProjectile(this, target, 'shuriken');
                                 audioManager.play('shurikenShoot');
                            }
                            else {
                                target.takeDamage(currentAttackPower);
                                audioManager.play('punch');
                            }
                        }
                    }
                }

                takeDamage(damage, effectInfo = {}) {
                    this.hp -= damage;
                    if (effectInfo.interrupt) {
                         if (this.weapon?.type !== 'shuriken' || effectInfo.force > 0) {
                             this.isCasting = false;
                             this.castingProgress = 0;
                         }
                    }
                    if (effectInfo.force && effectInfo.force > 0) {
                        this.knockbackX += Math.cos(effectInfo.angle) * effectInfo.force;
                        this.knockbackY += Math.sin(effectInfo.angle) * effectInfo.force;
                    }
                }

                update(enemies, weapons, projectiles) {
                    if (this.attackCooldown > 0) this.attackCooldown -= gameManager.gameSpeed;
                    if (this.teleportCooldown > 0) this.teleportCooldown -= gameManager.gameSpeed;
                    if (this.alertedCounter > 0) this.alertedCounter -= gameManager.gameSpeed;
                    if (this.isKing && this.spawnCooldown > 0) this.spawnCooldown -= gameManager.gameSpeed;
                    if (this.evasionCooldown > 0) this.evasionCooldown -= gameManager.gameSpeed;
                   
                    if (this.weapon && this.weapon.type === 'shuriken' && this.evasionCooldown <= 0) {
                        for (const p of projectiles) {
                            if (p.owner.team === this.team) continue;
                            const dist = Math.hypot(this.pixelX - p.pixelX, this.pixelY - p.pixelY);
                            if (dist < GRID_SIZE * 3) {
                                const angleToUnit = Math.atan2(this.pixelY - p.pixelY, this.pixelX - p.pixelX);
                                const angleDiff = Math.abs(angleToUnit - p.angle);
                                if (angleDiff < Math.PI / 4 || angleDiff > Math.PI * 1.75) {
                                    if (Math.random() > 0.5) {
                                        const dodgeAngle = p.angle + (Math.PI / 2) * (Math.random() < 0.5 ? 1 : -1);
                                        const dodgeForce = 4;
                                        this.knockbackX += Math.cos(dodgeAngle) * dodgeForce;
                                        this.knockbackY += Math.sin(dodgeAngle) * dodgeForce;
                                        this.evasionCooldown = 30;
                                        break;
                                    }
                                }
                            }
                        }
                    }
                   
                    this.applyPhysics();

                    const currentGridX = Math.floor(this.pixelX / GRID_SIZE);
                    const currentGridY = Math.floor(this.pixelY / GRID_SIZE);

                    this.isInMagneticField = gameManager.isPosInAnyField(currentGridX, currentGridY);
                    if(this.isInMagneticField) {
                        this.takeDamage(0.3 * gameManager.gameSpeed);
                    }

                    if (this.isCasting) {
                        this.castingProgress += gameManager.gameSpeed;
                        if (!this.target || this.target.hp <= 0) {
                            this.isCasting = false; this.castingProgress = 0; return;
                        }
                        if (this.castingProgress >= this.castDuration) {
                            this.isCasting = false; this.castingProgress = 0;
                            this.attackCooldown = this.cooldownTime;
                            if (this.weapon.type === 'staff') {
                                gameManager.castAreaSpell(this.castTargetPos, 'fire_pillar', this.attackPower, this.team);
                            } else if (this.weapon.type === 'hadoken') {
                                gameManager.createProjectile(this, this.target, 'hadoken');
                            }
                        }
                        return;
                    }

                    if (this.isKing && this.spawnCooldown <= 0) {
                        gameManager.spawnUnit(this, false);
                        this.spawnCooldown = this.spawnInterval;
                    }
                   
                    if(currentGridY >= 0 && currentGridY < ROWS && currentGridX >= 0 && currentGridX < COLS) {
                        const currentTile = gameManager.map[currentGridY][currentGridX];
                        if (currentTile.type === TILE.LAVA) this.hp -= 0.2 * gameManager.gameSpeed;
                        if (currentTile.type === TILE.HEAL_PACK) {
                            this.hp = 100;
                            gameManager.map[currentGridY][currentGridX] = { type: TILE.FLOOR, color: gameManager.currentFloorColor };
                            audioManager.play('heal');
                        }
                        if (currentTile.type === TILE.TELEPORTER && this.teleportCooldown <= 0) {
                            const teleporters = gameManager.getTilesOfType(TILE.TELEPORTER);
                            if (teleporters.length > 1) {
                                const otherTeleporter = teleporters.find(t => t.x !== currentGridX || t.y !== currentGridY);
                                if (otherTeleporter) {
                                    this.pixelX = otherTeleporter.x * GRID_SIZE + GRID_SIZE / 2;
                                    this.pixelY = otherTeleporter.y * GRID_SIZE + GRID_SIZE / 2;
                                    this.teleportCooldown = 120;
                                    audioManager.play('teleport');
                                }
                            }
                        }
                        if (currentTile.type === TILE.REPLICATION_TILE && !this.isKing) {
                            for(let i = 0; i < currentTile.replicationValue; i++) {
                                gameManager.spawnUnit(this, true);
                            }
                            gameManager.map[currentGridY][currentGridX] = { type: TILE.FLOOR, color: gameManager.currentFloorColor };
                            audioManager.play('replication');
                        }
                    }

                    let newState = 'IDLE';
                    let newTarget = null;
                   
                    if (this.isInMagneticField) {
                        newState = 'FLEEING_FIELD';
                    } else {
                        const enemyNexus = gameManager.nexuses.find(n => n.team !== this.team && !n.isDestroying);
                        const { item: closestEnemy, distance: enemyDist } = this.findClosest(enemies);
                        const { item: targetWeapon, distance: weaponDist } = this.findClosest(weapons.filter(w => !w.isEquipped));

                        let targetEnemy = null;
                        if (closestEnemy && enemyDist <= this.detectionRange && gameManager.hasLineOfSight(this, closestEnemy)) {
                            targetEnemy = closestEnemy;
                        }

                        if (this.isKing && targetEnemy) {
                            newState = 'FLEEING'; newTarget = targetEnemy;
                        } else if (this.hp < 50) {
                            const healPacks = gameManager.getTilesOfType(TILE.HEAL_PACK);
                            if (healPacks.length > 0) {
                                const healPackPositions = healPacks.map(pos => ({
                                    gridX: pos.x, gridY: pos.y,
                                    pixelX: pos.x * GRID_SIZE + GRID_SIZE / 2,
                                    pixelY: pos.y * GRID_SIZE + GRID_SIZE / 2
                                }));
                                const { item: closestPack, distance: packDist } = this.findClosest(healPackPositions);
                                if (closestPack && packDist < this.detectionRange * 1.5) {
                                    newState = 'SEEKING_HEAL_PACK';
                                    newTarget = closestPack;
                                }
                            }
                        }
                       
                        if (newState === 'IDLE') {
                            if (!this.weapon && targetWeapon && weaponDist <= this.detectionRange) {
                                newState = 'SEEKING_WEAPON';
                                newTarget = targetWeapon;
                            } else if (targetEnemy) {
                                newState = 'AGGRESSIVE';
                                newTarget = targetEnemy;
                            } else if (enemyNexus && gameManager.hasLineOfSight(this, enemyNexus) && Math.hypot(this.pixelX - enemyNexus.pixelX, this.pixelY - enemyNexus.pixelY) <= this.detectionRange) {
                                newState = 'ATTACKING_NEXUS';
                                newTarget = enemyNexus;
                            }
                        }
                    }

                    if (this.state !== newState && newState !== 'IDLE' && newState !== 'FLEEING_FIELD') this.alertedCounter = 60;
                    this.state = newState;
                    this.target = newTarget;
                   
                    switch(this.state) {
                        case 'FLEEING_FIELD':
                            this.moveTarget = gameManager.findClosestSafeSpot(this.pixelX, this.pixelY);
                            break;
                        case 'FLEEING':
                            if (this.target) {
                                const fleeAngle = Math.atan2(this.pixelY - this.target.pixelY, this.pixelX - this.target.pixelX);
                                this.moveTarget = { x: this.pixelX + Math.cos(fleeAngle) * GRID_SIZE * 5, y: this.pixelY + Math.sin(fleeAngle) * GRID_SIZE * 5 };
                            }
                            break;
                        case 'SEEKING_HEAL_PACK':
                            if (this.target) this.moveTarget = { x: this.target.pixelX, y: this.target.pixelY };
                            break;
                        case 'SEEKING_WEAPON':
                            if (this.target) {
                                const distance = Math.hypot(this.pixelX - this.target.pixelX, this.pixelY - this.target.pixelY);
                                if (distance < GRID_SIZE * 0.8 && !this.target.isEquipped) {
                                    this.equipWeapon(this.target.type);
                                    this.target.isEquipped = true;
                                    this.target = null;
                                } else {
                                    this.moveTarget = { x: this.target.pixelX, y: this.target.pixelY };
                                }
                            }
                            break;
                        case 'ATTACKING_NEXUS':
                        case 'AGGRESSIVE':
                            if (this.target) {
                                if (Math.hypot(this.pixelX - this.target.pixelX, this.pixelY - this.target.pixelY) <= this.attackRange) {
                                    this.moveTarget = null; this.attack(this.target);
                                    this.facingAngle = Math.atan2(this.target.pixelY - this.pixelY, this.target.pixelX - this.pixelX);
                                } else { this.moveTarget = { x: this.target.pixelX, y: this.target.pixelY }; }
                            }
                            break;
                        case 'IDLE': default:
                            if (!this.moveTarget || Math.hypot(this.pixelX - this.moveTarget.x, this.pixelY - this.moveTarget.y) < GRID_SIZE) {
                                const angle = Math.random() * Math.PI * 2;
                                this.moveTarget = { x: this.pixelX + Math.cos(angle) * GRID_SIZE * 8, y: this.pixelY + Math.sin(angle) * GRID_SIZE * 8 };
                            }
                            break;
                    }
                    this.move();
                }

                draw() {
                    switch(this.team) {
                        case TEAM.A: ctx.fillStyle = COLORS.TEAM_A; break;
                        case TEAM.B: ctx.fillStyle = COLORS.TEAM_B; break;
                        case TEAM.C: ctx.fillStyle = COLORS.TEAM_C; break;
                        case TEAM.D: ctx.fillStyle = COLORS.TEAM_D; break;
                    }
                    ctx.beginPath(); ctx.arc(this.pixelX, this.pixelY, GRID_SIZE / 2.5, 0, Math.PI * 2); ctx.fill();
                    ctx.strokeStyle = 'black'; ctx.lineWidth = 1; ctx.stroke();
                   
                    if (this.weapon && this.weapon.type === 'hadoken') {
                         ctx.save();
                         ctx.globalAlpha = 0.3 + Math.sin(gameManager.animationFrameCounter * 0.1) * 0.1;
                         ctx.fillStyle = '#a855f7';
                         ctx.beginPath();
                         ctx.arc(this.pixelX, this.pixelY, GRID_SIZE * 0.7, 0, Math.PI * 2);
                         ctx.fill();
                         ctx.restore();
                    }

                    if (this.weapon && this.weapon.type === 'dual_swords' && (this.state === 'AGGRESSIVE' || this.state === 'ATTACKING_NEXUS')) {
                        ctx.save();
                        ctx.globalAlpha = 0.3;
                        const backX = this.pixelX - Math.cos(this.facingAngle) * GRID_SIZE * 0.6;
                        const backY = this.pixelY - Math.sin(this.facingAngle) * GRID_SIZE * 0.6;
                        ctx.fillStyle = '#e5e7eb';
                        ctx.beginPath(); ctx.arc(backX, backY, GRID_SIZE / 3, 0, Math.PI * 2); ctx.fill();
                        ctx.globalAlpha = 0.2;
                        const backX2 = this.pixelX - Math.cos(this.facingAngle) * GRID_SIZE * 1.2;
                        const backY2 = this.pixelY - Math.sin(this.facingAngle) * GRID_SIZE * 1.2;
                        ctx.beginPath(); ctx.arc(backX2, backY2, GRID_SIZE / 3.5, 0, Math.PI * 2); ctx.fill();
                        ctx.restore();
                    }

                    if (this.isKing) {
                        ctx.save();
                        ctx.translate(this.pixelX, this.pixelY - GRID_SIZE * 0.5);
                        const scale = 1.2;
                        ctx.scale(scale, scale);
                        ctx.fillStyle = '#facc15'; ctx.strokeStyle = 'black'; ctx.lineWidth = 1 / scale;
                        ctx.beginPath();
                        ctx.moveTo(-GRID_SIZE * 0.4, -GRID_SIZE * 0.1); ctx.lineTo(-GRID_SIZE * 0.4, GRID_SIZE * 0.2);
                        ctx.lineTo(GRID_SIZE * 0.4, GRID_SIZE * 0.2); ctx.lineTo(GRID_SIZE * 0.4, -GRID_SIZE * 0.1);
                        ctx.lineTo(GRID_SIZE * 0.2, 0); ctx.lineTo(0, -GRID_SIZE * 0.1);
                        ctx.lineTo(-GRID_SIZE * 0.2, 0); ctx.closePath();
                        ctx.fill(); ctx.stroke();
                        ctx.restore();
                    }

                    if (this.weapon && !this.isKing) {
                        ctx.save(); ctx.translate(this.pixelX, this.pixelY);
                        ctx.rotate(this.facingAngle);

                        if (this.weapon.type === 'staff') {
                            ctx.translate(GRID_SIZE * 0.4, 0);
                            ctx.fillStyle = '#a16207'; ctx.fillRect(-1.5, -GRID_SIZE * 0.5, 3, GRID_SIZE * 1.0); ctx.strokeRect(-1.5, -GRID_SIZE * 0.5, 3, GRID_SIZE * 1.0);
                            ctx.fillStyle = '#a855f7'; ctx.beginPath(); ctx.arc(0, -GRID_SIZE * 0.6, GRID_SIZE * 0.2, 0, Math.PI * 2); ctx.fill(); ctx.stroke();
                        } else if (this.weapon.type === 'hadoken') {
                            ctx.translate(GRID_SIZE * 0.5, 0);
                            const scale = 0.7;
                            ctx.scale(scale, scale);
                            const grad = ctx.createRadialGradient(0, 0, 1, 0, 0, GRID_SIZE * 1.2);
                            grad.addColorStop(0, '#bfdbfe');
                            grad.addColorStop(0.6, '#3b82f6');
                            grad.addColorStop(1, '#1e40af');
                            ctx.fillStyle = grad;
                            ctx.strokeStyle = 'black';
                            ctx.lineWidth = 1.5 / scale;
                            ctx.beginPath();
                            ctx.arc(GRID_SIZE * 0.2, 0, GRID_SIZE * 0.6, -Math.PI / 2, Math.PI / 2, false);
                            ctx.lineTo(-GRID_SIZE * 0.8, 0);
                            ctx.closePath();
                            ctx.fill();
                            ctx.stroke();
                        } else if (this.weapon.type === 'shuriken') {
                            ctx.translate(GRID_SIZE * 0.4, GRID_SIZE * 0.3);
                            const scale = 0.5;
                            ctx.scale(scale, scale);
                            ctx.rotate(gameManager.animationFrameCounter * 0.1);
                            ctx.fillStyle = '#4a5568';
                            ctx.strokeStyle = 'black';
                            ctx.lineWidth = 2 / scale;
                            ctx.beginPath();
                            ctx.moveTo(0, -GRID_SIZE * 0.8);
                            ctx.lineTo(GRID_SIZE * 0.2, -GRID_SIZE * 0.2);
                            ctx.lineTo(GRID_SIZE * 0.8, 0);
                            ctx.lineTo(GRID_SIZE * 0.2, GRID_SIZE * 0.2);
                            ctx.lineTo(0, GRID_SIZE * 0.8);
                            ctx.lineTo(-GRID_SIZE * 0.2, GRID_SIZE * 0.2);
                            ctx.lineTo(-GRID_SIZE * 0.8, 0);
                            ctx.lineTo(-GRID_SIZE * 0.2, -GRID_SIZE * 0.2);
                            ctx.closePath();
                            ctx.fill();
                            ctx.stroke();
                        } else if (this.weapon.type === 'sword') {
                            ctx.translate(GRID_SIZE * 0.5, 0);
                            const bladeGradient = ctx.createLinearGradient(0, -GRID_SIZE, 0, 0);
                            bladeGradient.addColorStop(0, '#f3f4f6'); bladeGradient.addColorStop(1, '#9ca3af');
                            ctx.fillStyle = bladeGradient;
                            ctx.beginPath();
                            ctx.moveTo(-2, GRID_SIZE * 0.3); ctx.lineTo(-2, -GRID_SIZE * 1.0);
                            ctx.lineTo(0, -GRID_SIZE * 1.2); ctx.lineTo(2, -GRID_SIZE * 1.0);
                            ctx.lineTo(2, GRID_SIZE * 0.3);
                            ctx.closePath(); ctx.fill(); ctx.stroke();
                            ctx.fillStyle = '#374151';
                            ctx.beginPath();
                            ctx.moveTo(-GRID_SIZE * 0.4, GRID_SIZE * 0.3); ctx.lineTo(GRID_SIZE * 0.4, GRID_SIZE * 0.3);
                            ctx.lineTo(GRID_SIZE * 0.5, GRID_SIZE * 0.3 + 3); ctx.lineTo(-GRID_SIZE * 0.5, GRID_SIZE * 0.3 + 3);
                            ctx.closePath(); ctx.fill(); ctx.stroke();
                            ctx.fillStyle = '#1f2937';
                            ctx.fillRect(-1.5, GRID_SIZE * 0.3 + 3, 3, GRID_SIZE * 0.3); ctx.strokeRect(-1.5, GRID_SIZE * 0.3 + 3, 3, GRID_SIZE * 0.3);
                        } else if (this.weapon.type === 'bow') {
                            ctx.translate(GRID_SIZE * 0.4, 0);
                            ctx.rotate(-Math.PI / 4);
                            const scale = 0.8;
                            ctx.scale(scale, scale);
                            ctx.fillStyle = '#f3f4f6';
                            ctx.fillRect(-GRID_SIZE * 0.7, -1, GRID_SIZE * 1.2, 2);
                            ctx.strokeRect(-GRID_SIZE * 0.7, -1, GRID_SIZE * 1.2, 2);
                            ctx.fillStyle = '#e5e7eb';
                            ctx.beginPath(); ctx.moveTo(GRID_SIZE * 0.5, 0); ctx.lineTo(GRID_SIZE * 0.3, -3); ctx.lineTo(GRID_SIZE * 0.3, 3); ctx.closePath(); ctx.fill();
                            ctx.fillStyle = '#d1d5db';
                            ctx.beginPath(); ctx.moveTo(-GRID_SIZE * 0.6, -1); ctx.lineTo(-GRID_SIZE * 0.7, -4); ctx.lineTo(-GRID_SIZE * 0.5, -1); ctx.closePath(); ctx.fill()
                            ctx.beginPath(); ctx.moveTo(-GRID_SIZE * 0.6, 1); ctx.lineTo(-GRID_SIZE * 0.7, 4); ctx.lineTo(-GRID_SIZE * 0.5, 1); ctx.closePath(); ctx.fill()
                            ctx.strokeStyle = 'black'; ctx.lineWidth = 6 / scale; ctx.beginPath(); ctx.arc(0, 0, GRID_SIZE * 0.8, -Math.PI / 2.2, Math.PI / 2.2); ctx.stroke();
                            ctx.strokeStyle = '#854d0e'; ctx.lineWidth = 4 / scale; ctx.beginPath(); ctx.arc(0, 0, GRID_SIZE * 0.8, -Math.PI / 2.2, Math.PI / 2.2); ctx.stroke();
                            ctx.strokeStyle = '#e5e7eb'; ctx.lineWidth = 1.5 / scale; ctx.beginPath();
                            const arcRadius = GRID_SIZE * 0.8, arcAngle = Math.PI / 2.2;
                            ctx.moveTo(Math.cos(-arcAngle) * arcRadius, Math.sin(-arcAngle) * arcRadius);
                            ctx.lineTo(-GRID_SIZE * 0.4, 0);
                            ctx.lineTo(Math.cos(arcAngle) * arcRadius, Math.sin(arcAngle) * arcRadius); ctx.stroke();
                        } else if (this.weapon.type === 'dual_swords') {
                            const drawEquippedCurvedSword = (isRightHand) => {
                                ctx.save();
                                const yOffset = isRightHand ? GRID_SIZE * 0.6 : -GRID_SIZE * 0.6;
                                const rotation = isRightHand ? Math.PI / 8 : -Math.PI / 8;
                                ctx.translate(GRID_SIZE * 0.1, yOffset);
                                ctx.rotate(rotation);
                                ctx.fillStyle = '#374151';
                                ctx.fillRect(-GRID_SIZE * 0.05, 0, GRID_SIZE * 0.1, GRID_SIZE * 0.2);
                                ctx.strokeRect(-GRID_SIZE * 0.05, 0, GRID_SIZE * 0.1, GRID_SIZE * 0.2);
                                ctx.beginPath();
                                ctx.moveTo(-GRID_SIZE * 0.2, 0); ctx.lineTo(GRID_SIZE * 0.2, 0);
                                ctx.lineTo(GRID_SIZE * 0.2, -GRID_SIZE * 0.05); ctx.lineTo(-GRID_SIZE * 0.2, -GRID_SIZE * 0.05);
                                ctx.closePath(); ctx.fill(); ctx.stroke();
                                const bladeGradient = ctx.createLinearGradient(0, -GRID_SIZE*0.8, 0, 0);
                                bladeGradient.addColorStop(0, '#f3f4f6'); bladeGradient.addColorStop(0.5, '#9ca3af'); bladeGradient.addColorStop(1, '#4b5563');
                                ctx.fillStyle = bladeGradient;
                                ctx.beginPath();
                                ctx.moveTo(0, -GRID_SIZE * 0.05);
                                ctx.quadraticCurveTo(GRID_SIZE * 0.4, -GRID_SIZE * 0.3, 0, -GRID_SIZE * 0.8);
                                ctx.quadraticCurveTo(-GRID_SIZE * 0.1, -GRID_SIZE * 0.3, 0, -GRID_SIZE * 0.05);
                                ctx.closePath(); ctx.fill(); ctx.stroke();
                                ctx.restore();
                            };
                            drawEquippedCurvedSword(true);
                            drawEquippedCurvedSword(false);
                        }
                        ctx.restore();
                    }
                   
                    const hpBarYOffset = this.isKing ? GRID_SIZE * 1.0 : GRID_SIZE * 0.8;
                    const hpBarWidth = GRID_SIZE * 0.8, hpBarX = this.pixelX - hpBarWidth / 2, hpBarY = this.pixelY - hpBarYOffset;
                    ctx.fillStyle = '#111827'; ctx.fillRect(hpBarX, hpBarY, hpBarWidth, 5);
                    ctx.fillStyle = '#10b981'; ctx.fillRect(hpBarX, hpBarY, hpBarWidth * (this.hp / 100), 5);
                   
                    const skillBarY = hpBarY - 6;
                    if (this.isCasting) {
                        ctx.fillStyle = '#450a0a';
                        ctx.fillRect(hpBarX, skillBarY, hpBarWidth, 4);
                        ctx.fillStyle = '#ef4444';
                        ctx.fillRect(hpBarX, skillBarY, hpBarWidth * (this.castingProgress / this.castDuration), 4);
                    } else if (this.weapon && this.weapon.type === 'shuriken' && this.attackCooldown > 0) {
                        ctx.fillStyle = '#450a0a';
                        ctx.fillRect(hpBarX, skillBarY, hpBarWidth, 4);
                        ctx.fillStyle = '#ef4444';
                        ctx.fillRect(hpBarX, skillBarY, hpBarWidth * ((this.cooldownTime - this.attackCooldown) / this.cooldownTime), 4);
                    } else if (this.isKing && this.spawnCooldown > 0) {
                        ctx.fillStyle = '#450a0a';
                        ctx.fillRect(hpBarX, skillBarY, hpBarWidth, 4);
                        ctx.fillStyle = '#ef4444';
                        ctx.fillRect(hpBarX, skillBarY, hpBarWidth * ((this.spawnInterval - this.spawnCooldown) / this.spawnInterval), 4);
                    }
                   
                    if (this.alertedCounter > 0 && !(this.weapon && this.weapon.type === 'shuriken') && this.state !== 'FLEEING_FIELD') {
                        ctx.fillStyle = 'yellow'; ctx.font = 'bold 20px Arial'; ctx.textAlign = 'center';
                        ctx.fillText(this.state === 'SEEKING_HEAL_PACK' ? '+' : '!', this.pixelX, this.pixelY - GRID_SIZE);
                    }
                }
            }

            // 게임 관리자 클래스
            class GameManager {
                constructor() {
                    this.state = 'HOME';
                    this.currentMapId = null;
                    this.currentMapName = null;
                    this.map = [];
                    this.units = [];
                    this.weapons = [];
                    this.nexuses = [];
                    this.effects = [];
                    this.projectiles = [];
                    this.areaEffects = [];
                    this.growingFields = [];
                    this.currentTool = { tool: 'tile', type: 'FLOOR' };
                    this.isPainting = false;
                    this.dragStartPos = null;
                    this.initialUnitsState = [];
                    this.initialWeaponsState = [];
                    this.initialNexusesState = [];
                    this.initialMapState = [];
                    this.initialGrowingFieldsState = [];
                    this.animationFrameId = null;
                    this.animationFrameCounter = 0;
                    this.gameSpeed = 1;
                    this.currentWallColor = COLORS.WALL;
                    this.currentFloorColor = COLORS.FLOOR;
                    this.replicationValue = 2;
                    this.isActionCam = false;
                    this.actionCam = {
                        current: { x: 0, y: 0, scale: 1 },
                        target: { x: 0, y: 0, scale: 1 },
                        isAnimating: false
                    };
                    this.growingFieldSettings = {
                        direction: 'DOWN', speed: 4, delay: 0
                    };
                    this.autoMagneticField = {
                        isActive: false,
                        safeZoneSize: 6,
                        simulationTime: 0,
                        totalShrinkTime: 60 * 60,
                        currentBounds: { minX: 0, maxX: 0, minY: 0, maxY: 0 }
                    };
                    this.hadokenKnockback = 15;
                    this.initialNexusCount = 0;
                    this.winnerTeam = null;
                }

                init() {
                    if (!currentUser) return; // Wait for auth
                    this.setupEventListeners();
                    this.showHomeScreen();
                }
               
                // --- 화면 관리 ---
                showHomeScreen() {
                    this.state = 'HOME';
                    this.currentMapId = null;
                    this.currentMapName = null;
                    homeScreen.style.display = 'flex';
                    editorScreen.style.display = 'none';
                    this.renderMapCards();
                }

                async showEditorScreen(mapId) {
                    this.state = 'EDIT';
                    this.currentMapId = mapId;
                    homeScreen.style.display = 'none';
                    editorScreen.style.display = 'flex';
                    await audioManager.init();

                    const killSoundPref = localStorage.getItem('arenaKillSoundEnabled');
                    if (killSoundPref !== null) {
                        const isEnabled = killSoundPref === 'true';
                        killSoundToggle.checked = isEnabled;
                        audioManager.toggleKillSound(isEnabled);
                    }

                    await this.loadMapForEditing(mapId);
                }

                // --- Firestore 데이터 관리 ---
                async getAllMaps() {
                    if (!currentUser) return [];
                    const mapsColRef = collection(db, "maps", currentUser.uid, "userMaps");
                    const mapSnapshot = await getDocs(mapsColRef);
                    return mapSnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                }

                async getMapById(mapId) {
                    if (!currentUser) return null;
                    const mapDocRef = doc(db, "maps", currentUser.uid, "userMaps", mapId);
                    const mapSnap = await getDoc(mapDocRef);
                    return mapSnap.exists() ? { id: mapSnap.id, ...mapSnap.data() } : null;
                }

                async saveCurrentMap() {
                    if (!this.currentMapId || !currentUser || !this.currentMapName) return;

                    const plainUnits = this.units.map(u => ({...u}));
                    const plainWeapons = this.weapons.map(w => ({...w}));
                    const plainNexuses = this.nexuses.map(n => ({...n}));
                    const plainGrowingFields = this.growingFields.map(f => ({...f}));

                    const mapData = {
                        name: this.currentMapName,
                        width: canvas.width,
                        height: canvas.height,
                        map: JSON.stringify(this.map),
                        units: plainUnits,
                        weapons: plainWeapons,
                        nexuses: plainNexuses,
                        growingFields: plainGrowingFields,
                        autoMagneticField: this.autoMagneticField,
                        hadokenKnockback: this.hadokenKnockback,
                    };

                    const mapDocRef = doc(db, "maps", currentUser.uid, "userMaps", this.currentMapId);
                    try {
                        await setDoc(mapDocRef, mapData, { merge: true });
                        alert('맵이 Firebase에 저장되었습니다!');
                    } catch (error) {
                        console.error("Error saving map to Firebase: ", error);
                        alert('맵 저장에 실패했습니다.');
                    }
                }


                // --- 홈 화면 렌더링 ---
                async renderMapCards() {
                    document.getElementById('loadingStatus').textContent = "맵 목록을 불러오는 중...";
                    const maps = await this.getAllMaps();
                     document.getElementById('loadingStatus').style.display = 'none';

                    while (mapGrid.firstChild && mapGrid.firstChild !== addNewMapCard) {
                        mapGrid.removeChild(mapGrid.firstChild);
                    }

                    maps.forEach(mapData => {
                        const card = document.createElement('div');
                        card.className = 'map-card rounded-lg overflow-hidden flex flex-col cursor-pointer';
                        card.addEventListener('click', (e) => {
                            if (!e.target.closest('.map-menu-button')) {
                                this.showEditorScreen(mapData.id);
                            }
                        });

                        const previewCanvas = document.createElement('canvas');
                        previewCanvas.className = 'map-preview-canvas';
                       
                        const infoDiv = document.createElement('div');
                        infoDiv.className = 'p-3 flex-grow';
                        const nameP = document.createElement('p');
                        nameP.className = 'font-bold text-white truncate';
                        nameP.id = `map-name-${mapData.id}`;
                        nameP.textContent = mapData.name;
                        infoDiv.appendChild(nameP);

                        const menuButton = document.createElement('button');
                        menuButton.className = 'map-menu-button p-1 rounded-full hover:bg-gray-600';
                        menuButton.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 text-gray-300" viewBox="0 0 20 20" fill="currentColor"><path d="M10 6a2 2 0 110-4 2 2 0 010 4zM10 12a2 2 0 110-4 2 2 0 010 4zM10 18a2 2 0 110-4 2 2 0 010 4z" /></svg>`;
                       
                        const menu = document.createElement('div');
                        menu.className = 'map-menu p-2 rounded-md shadow-lg';
                        const renameBtn = document.createElement('button');
                        renameBtn.className = 'w-full text-left px-3 py-1.5 text-sm rounded hover:bg-gray-500';
                        renameBtn.textContent = '이름 변경';
                        renameBtn.onclick = () => {
                            menu.style.display = 'none';
                            this.openRenameModal(mapData.id, mapData.name);
                        };
                        const deleteBtn = document.createElement('button');
                        deleteBtn.className = 'w-full text-left px-3 py-1.5 text-sm text-red-400 rounded hover:bg-gray-500';
                        deleteBtn.textContent = '삭제';
                        deleteBtn.onclick = () => {
                            menu.style.display = 'none';
                            this.openDeleteConfirmModal(mapData.id, mapData.name);
                        };
                        menu.append(renameBtn, deleteBtn);

                        menuButton.addEventListener('click', (e) => {
                            e.stopPropagation();
                            menu.style.display = menu.style.display === 'block' ? 'none' : 'block';
                        });

                        card.append(previewCanvas, infoDiv, menuButton, menu);
                        mapGrid.insertBefore(card, addNewMapCard);

                        this.drawMapPreview(previewCanvas, mapData);
                    });

                    document.addEventListener('click', (e) => {
                        document.querySelectorAll('.map-menu').forEach(menu => {
                            if (!menu.previousElementSibling.contains(e.target)) {
                                menu.style.display = 'none';
                            }
                        });
                    });
                }

                drawMapPreview(previewCanvas, mapData) {
                    const prevCtx = previewCanvas.getContext('2d');
                    const mapWidth = mapData.width;
                    const mapHeight = mapData.height;
                   
                    previewCanvas.width = mapWidth / 5;
                    previewCanvas.height = mapHeight / 5;

                    const pixelSizeX = previewCanvas.width / (mapWidth / GRID_SIZE);
                    const pixelSizeY = previewCanvas.height / (mapHeight / GRID_SIZE);

                    prevCtx.fillStyle = '#111827';
                    prevCtx.fillRect(0, 0, previewCanvas.width, previewCanvas.height);
                   
                    const mapGridData = (typeof mapData.map === 'string') ? JSON.parse(mapData.map) : mapData.map;
                    mapGridData.forEach((row, y) => {
                        row.forEach((tile, x) => {
                            switch(tile.type) {
                                case TILE.WALL: prevCtx.fillStyle = tile.color || COLORS.WALL; break;
                                case TILE.FLOOR: prevCtx.fillStyle = tile.color || COLORS.FLOOR; break;
                                case TILE.LAVA: prevCtx.fillStyle = COLORS.LAVA; break;
                                case TILE.CRACKED_WALL: prevCtx.fillStyle = COLORS.CRACKED_WALL; break;
                                case TILE.HEAL_PACK: prevCtx.fillStyle = COLORS.HEAL_PACK; break;
                                case TILE.REPLICATION_TILE: prevCtx.fillStyle = COLORS.REPLICATION_TILE; break;
                                case TILE.TELEPORTER: prevCtx.fillStyle = COLORS.TELEPORTER; break;
                                default: prevCtx.fillStyle = COLORS.FLOOR; break;
                            }
                            prevCtx.fillRect(x * pixelSizeX, y * pixelSizeY, pixelSizeX, pixelSizeY);
                        });
                    });
                   
                    const drawItem = (item, colorOverride = null) => {
                        let color;
                        if (colorOverride) {
                            color = colorOverride;
                        } else {
                            switch(item.team) {
                                case TEAM.A: color = COLORS.TEAM_A; break;
                                case TEAM.B: color = COLORS.TEAM_B; break;
                                case TEAM.C: color = COLORS.TEAM_C; break;
                                case TEAM.D: color = COLORS.TEAM_D; break;
                                default: color = '#9ca3af'; break;
                            }
                        }
                        prevCtx.fillStyle = color;
                        prevCtx.fillRect(item.gridX * pixelSizeX, item.gridY * pixelSizeY, pixelSizeX, pixelSizeY);
                    };

                    (mapData.nexuses || []).forEach(item => drawItem(item));
                    (mapData.units || []).forEach(item => drawItem(item));
                    (mapData.weapons || []).forEach(item => drawItem(item, '#eab308'));
                }
               
                // --- 모달 관리 ---
                openRenameModal(mapId, currentName) {
                    const input = document.getElementById('renameMapInput');
                    input.value = currentName;
                    renameMapModal.style.display = 'flex';
                   
                    document.getElementById('confirmRenameBtn').onclick = async () => {
                        const newName = input.value.trim();
                        if (newName && currentUser) {
                            const mapDocRef = doc(db, "maps", currentUser.uid, "userMaps", mapId);
                            try {
                                await setDoc(mapDocRef, { name: newName }, { merge: true });
                                this.currentMapName = newName; // Update internal state if it's the current map
                                this.renderMapCards();
                            } catch (error) {
                                console.error("Error renaming map: ", error);
                            }
                            renameMapModal.style.display = 'none';
                        }
                    };
                }

                openDeleteConfirmModal(mapId, mapName) {
                    document.getElementById('deleteConfirmText').textContent = `'${mapName}' 맵을 정말 삭제하시겠습니까? 이 작업은 되돌릴 수 없습니다.`;
                    deleteConfirmModal.style.display = 'flex';

                    document.getElementById('confirmDeleteBtn').onclick = async () => {
                        if (!currentUser) return;
                        const mapDocRef = doc(db, "maps", currentUser.uid, "userMaps", mapId);
                        try {
                            await deleteDoc(mapDocRef);
                            this.renderMapCards();
                        } catch (error) {
                            console.error("Error deleting map: ", error);
                        }
                        deleteConfirmModal.style.display = 'none';
                    };
                }

                setupEventListeners() {
                    // 홈 화면 이벤트
                    addNewMapCard.addEventListener('click', () => {
                        document.getElementById('newMapName').value = '';
                        document.getElementById('newMapWidth').value = '600';
                        document.getElementById('newMapHeight').value = '900';
                        newMapModal.style.display = 'flex';
                    });

                    document.getElementById('confirmNewMapBtn').addEventListener('click', async () => {
                        if (!currentUser) return;
                        const name = document.getElementById('newMapName').value.trim() || '새로운 맵';
                        const width = parseInt(document.getElementById('newMapWidth').value) || 600;
                        const height = parseInt(document.getElementById('newMapHeight').value) || 900;
                       
                        const newMapId = `map_${Date.now()}`;
                        const newMapData = {
                            id: newMapId,
                            name: name,
                            width: width,
                            height: height,
                            map: JSON.stringify(Array(Math.floor(height / GRID_SIZE)).fill().map(() => Array(Math.floor(width / GRID_SIZE)).fill({ type: TILE.FLOOR, color: COLORS.FLOOR }))),
                            units: [], weapons: [], nexuses: [], growingFields: []
                        };
                       
                        const newMapDocRef = doc(db, "maps", currentUser.uid, "userMaps", newMapId);
                        try {
                            await setDoc(newMapDocRef, newMapData);
                            newMapModal.style.display = 'none';
                            this.showEditorScreen(newMapId);
                        } catch(error) {
                            console.error("Error creating new map: ", error);
                        }
                    });
                    document.getElementById('cancelNewMapBtn').addEventListener('click', () => newMapModal.style.display = 'none');
                    document.getElementById('cancelRenameBtn').addEventListener('click', () => renameMapModal.style.display = 'none');
                    document.getElementById('cancelDeleteBtn').addEventListener('click', () => deleteConfirmModal.style.display = 'none');


                    // 에디터 화면 이벤트
                    backToHomeBtn.addEventListener('click', () => this.showHomeScreen());
                    saveMapBtn.addEventListener('click', () => this.saveCurrentMap());
                    muteBtn.addEventListener('click', () => audioManager.toggleMute());
                    mapSettingsBtn.addEventListener('click', () => {
                        widthInput.value = canvas.width;
                        heightInput.value = canvas.height;
                        mapSettingsModal.style.display = 'flex';
                    });
                    closeMapSettingsModal.addEventListener('click', () => {
                        mapSettingsModal.style.display = 'none';
                    });
                    killSoundToggle.addEventListener('change', (e) => {
                        audioManager.toggleKillSound(e.target.checked);
                    });

                    toolbox.addEventListener('click', (e) => this.selectTool(e));
                    canvas.addEventListener('mousedown', (e) => {
                        if (this.isActionCam) {
                            if (this.actionCam.isAnimating) return;
                            const pos = this.getMousePos(e);
                            if (this.actionCam.target.scale === 1) {
                                this.actionCam.target.x = pos.pixelX;
                                this.actionCam.target.y = pos.pixelY;
                                this.actionCam.target.scale = 1.8;
                            } else {
                                this.actionCam.target.x = canvas.width / 2;
                                this.actionCam.target.y = canvas.height / 2;
                                this.actionCam.target.scale = 1;
                            }
                            this.actionCam.isAnimating = true;
                            if (this.state !== 'SIMULATE' && !this.animationFrameId) {
                                this.gameLoop();
                            }
                            return;
                        }

                        if (this.state === 'EDIT') {
                            const pos = this.getMousePos(e);
                           
                            this.isPainting = true;
                            if (this.currentTool.tool === 'growing_field') {
                                this.dragStartPos = pos;
                            } else {
                                this.applyTool(pos);
                            }
                        }
                    });
                    canvas.addEventListener('mouseup', (e) => {
                        if (this.state === 'EDIT' && this.currentTool.tool === 'growing_field' && this.dragStartPos) {
                            const pos = this.getMousePos(e);
                            this.applyTool(pos);
                        }
                        this.isPainting = false;
                        this.dragStartPos = null;
                    });
                    canvas.addEventListener('mousemove', (e) => {
                        if (this.isPainting && this.state === 'EDIT' && this.currentTool.tool !== 'growing_field') {
                            const pos = this.getMousePos(e);
                            this.applyTool(pos);
                        }
                        if (this.state === 'EDIT' && this.dragStartPos) {
                           this.draw(e);
                        }
                    });
                    canvas.addEventListener('mouseleave', () => {
                        this.isPainting = false;
                        this.dragStartPos = null;
                        this.draw();
                    });

                    simStartBtn.addEventListener('click', () => this.startSimulation());
                    simPauseBtn.addEventListener('click', () => this.pauseSimulation());
                    simPlayBtn.addEventListener('click', () => this.playSimulation());
                    simPlacementResetBtn.addEventListener('click', () => this.resetPlacement());
                    simResetBtn.addEventListener('click', () => this.resetMap());
                    resizeBtn.addEventListener('click', () => {
                        this.resizeCanvas(parseInt(widthInput.value), parseInt(heightInput.value));
                        mapSettingsModal.style.display = 'none';
                    });
                    actionCamToggle.addEventListener('change', (e) => {
                        this.isActionCam = e.target.checked;
                        if (!this.isActionCam) {
                            this.resetActionCam(false);
                        }
                    });

                    growingFieldSettingsBtn.addEventListener('click', () => {
                        document.getElementById('fieldDirection').value = this.growingFieldSettings.direction;
                        document.getElementById('fieldSpeed').value = this.growingFieldSettings.speed;
                        document.getElementById('fieldDelay').value = this.growingFieldSettings.delay;
                        growingFieldModal.style.display = 'flex';
                    });
                    closeGrowingFieldModal.addEventListener('click', () => {
                        this.growingFieldSettings.direction = document.getElementById('fieldDirection').value;
                        this.growingFieldSettings.speed = parseFloat(document.getElementById('fieldSpeed').value);
                        this.growingFieldSettings.delay = parseInt(document.getElementById('fieldDelay').value);
                        growingFieldModal.style.display = 'none';
                    });
                     growingFieldDefaultBtn.addEventListener('click', () => {
                        this.growingFieldSettings = { direction: 'DOWN', speed: 4, delay: 0 };
                        document.getElementById('fieldDirection').value = this.growingFieldSettings.direction;
                        document.getElementById('fieldSpeed').value = this.growingFieldSettings.speed;
                        document.getElementById('fieldDelay').value = this.growingFieldSettings.delay;
                    });

                    autoFieldSettingsBtn.addEventListener('click', () => {
                        document.getElementById('autoFieldActiveToggle').checked = this.autoMagneticField.isActive;
                        document.getElementById('autoFieldShrinkTime').value = this.autoMagneticField.totalShrinkTime / 60;
                        document.getElementById('autoFieldSafeZoneSize').value = this.autoMagneticField.safeZoneSize;
                        autoFieldModal.style.display = 'flex';
                    });
                    closeAutoFieldModal.addEventListener('click', () => {
                        this.autoMagneticField.isActive = document.getElementById('autoFieldActiveToggle').checked;
                        this.autoMagneticField.totalShrinkTime = parseFloat(document.getElementById('autoFieldShrinkTime').value) * 60;
                        this.autoMagneticField.safeZoneSize = parseInt(document.getElementById('autoFieldSafeZoneSize').value);
                        autoFieldModal.style.display = 'none';
                    });
                     autoFieldDefaultBtn.addEventListener('click', () => {
                        this.autoMagneticField.isActive = false;
                        this.autoMagneticField.totalShrinkTime = 60 * 60;
                        this.autoMagneticField.safeZoneSize = 6;
                        document.getElementById('autoFieldActiveToggle').checked = this.autoMagneticField.isActive;
                        document.getElementById('autoFieldShrinkTime').value = this.autoMagneticField.totalShrinkTime / 60;
                        document.getElementById('autoFieldSafeZoneSize').value = this.autoMagneticField.safeZoneSize;
                    });
                   
                    hadokenSettingsBtn.addEventListener('click', () => {
                        hadokenKnockbackSlider.value = this.hadokenKnockback;
                        hadokenKnockbackValue.textContent = this.hadokenKnockback;
                        hadokenModal.style.display = 'flex';
                    });
                    closeHadokenModal.addEventListener('click', () => {
                        hadokenModal.style.display = 'none';
                    });
                    hadokenKnockbackSlider.addEventListener('input', (e) => {
                        this.hadokenKnockback = parseInt(e.target.value);
                        hadokenKnockbackValue.textContent = this.hadokenKnockback;
                    });
                    hadokenDefaultBtn.addEventListener('click', () => {
                        this.hadokenKnockback = 15;
                        hadokenKnockbackSlider.value = this.hadokenKnockback;
                        hadokenKnockbackValue.textContent = this.hadokenKnockback;
                    });


                    document.querySelectorAll('.category-header').forEach(header => {
                        header.addEventListener('click', () => {
                            const targetId = header.dataset.target;
                            const content = document.getElementById(targetId);
                            if (content.style.maxHeight) {
                                content.style.maxHeight = null;
                            } else {
                                content.style.maxHeight = content.scrollHeight + "px";
                            }
                        });
                    });
                    document.getElementById('replicationValue').addEventListener('change', (e) => {
                        this.replicationValue = parseInt(e.target.value) || 1;
                    });
                    document.getElementById('wallColorPicker').addEventListener('input', (e) => {
                        this.currentWallColor = e.target.value;
                        this.draw();
                    });
                    document.getElementById('floorColorPicker').addEventListener('input', (e) => {
                        this.currentFloorColor = e.target.value;
                        this.draw();
                    });
                }

                resizeCanvas(width, height) {
                    canvas.width = width;
                    canvas.height = height;
                    widthInput.value = width;
                    heightInput.value = height;
                    COLS = Math.floor(canvas.width / GRID_SIZE);
                    ROWS = Math.floor(canvas.height / GRID_SIZE);
                   
                    this.resetMap();
                   
                    this.actionCam.current.x = canvas.width / 2;
                    this.actionCam.current.y = canvas.height / 2;
                    this.actionCam.target.x = canvas.width / 2;
                    this.actionCam.target.y = canvas.height / 2;
                }

                resetMap() {
                    cancelAnimationFrame(this.animationFrameId);
                    this.animationFrameId = null;
                    this.state = 'EDIT';
                    this.map = Array(ROWS).fill().map(() => Array(COLS).fill().map(() => ({ type: TILE.FLOOR, color: this.currentFloorColor })));
                    this.units = []; this.weapons = []; this.nexuses = []; this.growingFields = [];
                    this.effects = []; this.projectiles = []; this.areaEffects = [];
                    this.initialUnitsState = []; this.initialWeaponsState = [];
                    this.initialNexusesState = []; this.initialMapState = [];
                    this.initialGrowingFieldsState = [];
                    statusText.textContent = "에디터 모드";
                    simStartBtn.classList.remove('hidden');
                    simPauseBtn.classList.add('hidden');
                    simPlayBtn.classList.add('hidden');
                    simStartBtn.disabled = false;
                    toolbox.style.pointerEvents = 'auto';
                    this.resetActionCam(true);
                    this.draw();
                }

                resetPlacement() {
                    if (this.initialUnitsState.length === 0) {
                        console.warn("배치 초기화를 하려면 먼저 시뮬레이션을 한 번 시작해야 합니다.");
                        return;
                    }

                    cancelAnimationFrame(this.animationFrameId);
                    this.animationFrameId = null;
                    this.state = 'EDIT';
                    this.units = JSON.parse(this.initialUnitsState).map(u => Object.assign(new Unit(0,0), u));
                    this.weapons = JSON.parse(this.initialWeaponsState).map(w => Object.assign(new Weapon(0,0), w));
                    this.nexuses = JSON.parse(this.initialNexusesState).map(n => Object.assign(new Nexus(0,0), n));
                    this.map = JSON.parse(this.initialMapState);
                    this.growingFields = JSON.parse(this.initialGrowingFieldsState).map(fieldData => {
                         const settings = {
                             direction: fieldData.direction,
                             speed: fieldData.totalFrames / 60,
                             delay: fieldData.delay / 60,
                         };
                        return new GrowingMagneticField(fieldData.id, fieldData.gridX, fieldData.gridY, fieldData.width, fieldData.height, settings);
                    });
                    this.effects = []; this.projectiles = []; this.areaEffects = [];
                    statusText.textContent = "에디터 모드";
                    simStartBtn.classList.remove('hidden');
                    simPauseBtn.classList.add('hidden');
                    simPlayBtn.classList.add('hidden');
                    simStartBtn.disabled = false;
                    toolbox.style.pointerEvents = 'auto';
                    this.resetActionCam(true);
                    this.draw();
                }

                resetActionCam(immediate = false) {
                    this.isActionCam = false;
                    actionCamToggle.checked = false;
                   
                    const target = {
                        x: canvas.width / 2,
                        y: canvas.height / 2,
                        scale: 1
                    };

                    if (immediate) {
                        this.actionCam.current = { ...target };
                        this.actionCam.target = { ...target };
                        this.actionCam.isAnimating = false;
                    } else if (!this.actionCam.isAnimating) {
                        this.actionCam.target = target;
                        this.actionCam.isAnimating = true;
                        if (this.state !== 'SIMULATE' && this.state !== 'PAUSED' && !this.animationFrameId) {
                            this.gameLoop();
                        }
                    }
                }

                selectTool(e) {
                    const button = e.target.closest('.tool-btn');
                    if (!button) return;
                    document.querySelectorAll('.tool-btn').forEach(btn => btn.classList.remove('selected', 'team-a', 'team-b', 'team-c', 'team-d'));
                   
                    const { tool, team, type } = button.dataset;

                    if(tool !== 'auto_field') { // 자동 자기장은 선택 상태를 유지하지 않음
                        button.classList.add('selected');
                        if (team) button.classList.add(`team-${team.toLowerCase()}`);
                    }
                   
                    this.currentTool = { tool, team, type };
                    growingFieldSettingsBtn.style.display = (tool === 'growing_field') ? 'block' : 'none';
                    autoFieldSettingsBtn.style.display = (tool === 'auto_field') ? 'block' : 'none';
                    hadokenSettingsBtn.style.display = (tool === 'weapon' && type === 'hadoken') ? 'block' : 'none';
                }

                getMousePos(e) {
                     const rect = canvas.getBoundingClientRect();
                     const transform = ctx.getTransform();
                     const invTransform = transform.inverse();

                     const canvasX = e.clientX - rect.left;
                     const canvasY = e.clientY - rect.top;

                     const worldX = canvasX * invTransform.a + canvasY * invTransform.c + invTransform.e;
                     const worldY = canvasX * invTransform.b + canvasY * invTransform.d + invTransform.f;
                   
                     return {
                         pixelX: worldX,
                         pixelY: worldY,
                         gridX: Math.floor(worldX / GRID_SIZE),
                         gridY: Math.floor(worldY / GRID_SIZE)
                     };
                }

                applyTool(pos) {
                    const {gridX: x, gridY: y} = pos;
                    if (x < 0 || x >= COLS || y < 0 || y >= ROWS) return;
                   
                    if (this.currentTool.tool === 'erase') {
                        this.map[y][x] = { type: TILE.FLOOR, color: this.currentFloorColor };
                        this.units = this.units.filter(u => u.gridX !== x || u.gridY !== y);
                        this.weapons = this.weapons.filter(w => w.gridX !== x || w.gridY !== y);
                        this.nexuses = this.nexuses.filter(n => n.gridX !== x || n.gridY !== y);
                        this.growingFields = this.growingFields.filter(zone => !(x >= zone.gridX && x < zone.gridX + zone.width && y >= zone.gridY && y < zone.gridY + zone.height));
                        this.draw();
                        return;
                    }

                    const itemExists = this.units.some(u => u.gridX === x && u.gridY === y) || 
                                     this.weapons.some(w => w.gridX === x && w.gridY === y) || 
                                     this.nexuses.some(n => n.gridX === x && n.gridY === y);

                    if (this.currentTool.tool === 'growing_field' && this.dragStartPos) {
                         const startX = Math.min(this.dragStartPos.gridX, x);
                         const startY = Math.min(this.dragStartPos.gridY, y);
                         const endX = Math.max(this.dragStartPos.gridX, x);
                         const endY = Math.max(this.dragStartPos.gridY, y);
                         const width = endX - startX + 1;
                         const height = endY - startY + 1;
                         
                         const newZone = new GrowingMagneticField(Date.now(), startX, startY, width, height, {...this.growingFieldSettings});
                         this.growingFields.push(newZone);
                         this.dragStartPos = null;
                    } else if (this.currentTool.tool === 'tile') {
                        if (itemExists) return;
                        const tileType = TILE[this.currentTool.type];
                        if (tileType === TILE.TELEPORTER && this.getTilesOfType(TILE.TELEPORTER).length >= 2) { return; }
                        this.map[y][x] = {
                            type: tileType,
                            hp: tileType === TILE.CRACKED_WALL ? 50 : undefined,
                            color: tileType === TILE.WALL ? this.currentWallColor : (tileType === TILE.FLOOR ? this.currentFloorColor : undefined),
                            replicationValue: tileType === TILE.REPLICATION_TILE ? this.replicationValue : undefined
                        };
                    } else if (this.currentTool.tool === 'unit' && !itemExists) {
                        this.units.push(new Unit(x, y, this.currentTool.team));
                    } else if (this.currentTool.tool === 'weapon' && !itemExists) {
                        const weapon = this.createWeapon(x, y, this.currentTool.type);
                        this.weapons.push(weapon);
                    } else if (this.currentTool.tool === 'nexus' && !itemExists) {
                        if (this.nexuses.some(n => n.team === this.currentTool.team)) { return; }
                        this.nexuses.push(new Nexus(x, y, this.currentTool.team));
                    }
                    this.draw();
                }

                startSimulation() {
                    if (this.state !== 'EDIT') return;
                    this.initialUnitsState = JSON.stringify(this.units.map(u => ({...u})));
                    this.initialWeaponsState = JSON.stringify(this.weapons.map(w => ({...w})));
                    this.initialNexusesState = JSON.stringify(this.nexuses.map(n => ({...n})));
                    this.initialMapState = JSON.stringify(this.map);
                    this.initialGrowingFieldsState = JSON.stringify(this.growingFields.map(f => ({...f})));
                    this.initialNexusCount = this.nexuses.length;
                    this.winnerTeam = null;

                    this.state = 'SIMULATE';
                    statusText.textContent = "시뮬레이션 진행 중...";
                    simStartBtn.classList.add('hidden');
                    simPauseBtn.classList.remove('hidden');
                    simPlayBtn.classList.add('hidden');
                    toolbox.style.pointerEvents = 'none';
                    this.gameLoop();
                }

                pauseSimulation() {
                    if (this.state !== 'SIMULATE') return;
                    this.state = 'PAUSED';
                    statusText.textContent = "일시정지됨";
                    simPauseBtn.classList.add('hidden');
                    simPlayBtn.classList.remove('hidden');
                }

                playSimulation() {
                    if (this.state !== 'PAUSED') return;
                    this.state = 'SIMULATE';
                    statusText.textContent = "시뮬레이션 진행 중...";
                    simPauseBtn.classList.remove('hidden');
                    simPlayBtn.classList.add('hidden');
                    this.gameLoop();
                }

                gameLoop() {
                    this.animationFrameCounter++;
                   
                    if (this.actionCam.isAnimating) {
                        const cam = this.actionCam;
                        const ease = 0.15; // 액션캠 속도 증가
                        cam.current.x += (cam.target.x - cam.current.x) * ease;
                        cam.current.y += (cam.target.y - cam.current.y) * ease;
                        cam.current.scale += (cam.target.scale - cam.current.scale) * ease;

                        if (Math.abs(cam.current.scale - cam.target.scale) < 0.001 && Math.abs(cam.current.x - cam.target.x) < 0.1) {
                            cam.current = { ...cam.target };
                            cam.isAnimating = false;
                        }
                    }

                    if (this.state === 'SIMULATE' || this.state === 'ENDING') {
                        this.update();
                    }
                   
                    this.draw();
                   
                    if (this.state === 'SIMULATE') {
                        const activeNexuses = this.nexuses.filter(n => !n.isDestroying);
                        const activeNexusTeams = new Set(activeNexuses.map(n => n.team));
                        const activeUnitTeams = new Set(this.units.map(u => u.team));
                       
                        let gameOver = false;
                        let winner = null;

                        if (this.initialNexusCount >= 2) {
                            if (activeNexusTeams.size === 1) {
                                gameOver = true;
                                winner = activeNexusTeams.values().next().value;
                            }
                        } else if (this.initialNexusCount === 1) {
                            if (activeNexusTeams.size === 0) {
                                gameOver = true;
                                winner = activeUnitTeams.size > 0 ? activeUnitTeams.values().next().value : null;
                            }
                        }

                        if (!gameOver) {
                            const allRemainingTeams = new Set([...activeNexusTeams, ...activeUnitTeams]);
                             if (allRemainingTeams.size <= 1 && (this.units.length > 0 || this.nexuses.length > 0) ) {
                                const initialTeams = new Set(JSON.parse(this.initialNexusesState).map(n => n.team).concat(JSON.parse(this.initialUnitsState).map(u => u.team)));
                                if (initialTeams.size > 1) {
                                    gameOver = true;
                                    winner = allRemainingTeams.size === 1 ? allRemainingTeams.values().next().value : null;
                                }
                            } else if (this.units.length === 0 && activeNexusTeams.size <= 1) {
                                gameOver = true;
                                winner = activeNexusTeams.size === 1 ? activeNexusTeams.values().next().value : null;
                            }
                        }

                        if (gameOver) {
                            this.state = 'ENDING';
                            this.winnerTeam = winner;
                        }
                    } else if (this.state === 'ENDING') {
                        const explosionsFinished = this.nexuses.every(n => !n.isDestroying || n.explosionParticles.length === 0);
                        if (explosionsFinished) {
                            this.state = 'DONE';
                            let winnerName = "무승부";
                            if(this.winnerTeam) {
                                switch(this.winnerTeam) {
                                    case TEAM.A: winnerName = "빨강 팀"; break;
                                    case TEAM.B: winnerName = "파랑 팀"; break;
                                    case TEAM.C: winnerName = "초록 팀"; break;
                                    case TEAM.D: winnerName = "노랑 팀"; break;
                                }
                                statusText.textContent = `${winnerName} 승리!`;
                            } else {
                                statusText.textContent = "무승부!";
                            }
                            simPauseBtn.classList.add('hidden');
                            simPlayBtn.classList.add('hidden');
                            this.resetActionCam(false);
                        }
                    }

                    if (this.state === 'DONE' && !this.actionCam.isAnimating) {
                        cancelAnimationFrame(this.animationFrameId);
                        this.animationFrameId = null;
                    } else if (this.state === 'PAUSED' && !this.actionCam.isAnimating) {
                        cancelAnimationFrame(this.animationFrameId);
                        this.animationFrameId = null;
                    } else {
                        this.animationFrameId = requestAnimationFrame(() => this.gameLoop());
                    }
                }

                update() {
                    if (this.state === 'PAUSED' || this.state === 'DONE') return;

                    if (this.state === 'ENDING') {
                        this.nexuses.forEach(n => n.update());
                        this.projectiles.forEach(p => p.update());
                        this.projectiles = this.projectiles.filter(p => !p.destroyed);
                        return;
                    }

                    this.gameSpeed = 1;

                    if (this.autoMagneticField.isActive) {
                        this.autoMagneticField.simulationTime++;
                        const progress = Math.min(1, this.autoMagneticField.simulationTime / this.autoMagneticField.totalShrinkTime);
                       
                        const finalWidth = this.autoMagneticField.safeZoneSize;
                        const finalHeight = this.autoMagneticField.safeZoneSize;
                       
                        const finalMinX = (COLS - finalWidth) / 2;
                        const finalMaxX = (COLS + finalWidth) / 2;
                        const finalMinY = (ROWS - finalHeight) / 2;
                        const finalMaxY = (ROWS + finalHeight) / 2;

                        this.autoMagneticField.currentBounds.minX = 0 + (finalMinX - 0) * progress;
                        this.autoMagneticField.currentBounds.maxX = COLS - (COLS - finalMaxX) * progress;
                        this.autoMagneticField.currentBounds.minY = 0 + (finalMinY - 0) * progress;
                        this.autoMagneticField.currentBounds.maxY = ROWS - (ROWS - finalMaxY) * progress;
                    }
                   
                    this.growingFields.forEach(field => field.update());
                   
                    const unitsBeforeUpdate = this.units.length;

                    const unitsByTeam = {};
                    for (const unit of this.units) {
                        if (!unitsByTeam[unit.team]) {
                            unitsByTeam[unit.team] = [];
                        }
                        unitsByTeam[unit.team].push(unit);
                    }
                    const allTeamKeys = Object.keys(unitsByTeam);
                    
                    this.units.forEach(unit => {
                        const enemyTeams = allTeamKeys.filter(key => key !== unit.team);
                        const enemies = enemyTeams.flatMap(key => unitsByTeam[key]);
                        unit.update(enemies, this.weapons, this.projectiles);
                    });
                    
                    this.units = this.units.filter(u => u.hp > 0);
                    if (this.units.length < unitsBeforeUpdate) {
                        audioManager.play('unitDeath');
                    }
                   
                    this.nexuses.forEach(n => n.update());

                    this.projectiles.forEach(p => p.update());
                    this.projectiles = this.projectiles.filter(p => !p.destroyed);

                    for (let i = this.projectiles.length - 1; i >= 0; i--) {
                        const p = this.projectiles[i]; let hit = false;
                        for (const unit of this.units) {
                            if (p.owner.team !== unit.team && Math.hypot(p.pixelX - unit.pixelX, p.pixelY - unit.pixelY) < GRID_SIZE / 2) {
                                const effectInfo = {
                                    interrupt: p.type === 'hadoken',
                                    force: p.knockback,
                                    angle: p.angle
                                };
                                unit.takeDamage(p.damage, effectInfo);
                                if (p.type === 'arrow') audioManager.play('arrowHit');
                                if (p.type === 'hadoken') audioManager.play('hadokenHit');
                                hit = true;
                                break;
                            }
                        }
                        if (!hit) {
                            for (const nexus of this.nexuses) {
                                if (p.owner.team !== nexus.team && Math.hypot(p.pixelX - nexus.pixelX, p.pixelY - nexus.pixelY) < GRID_SIZE) {
                                    nexus.takeDamage(p.damage);
                                    hit = true;
                                    break;
                                }
                            }
                        }
                        if (hit || p.pixelX < 0 || p.pixelX > canvas.width || p.pixelY < 0 || p.pixelY > canvas.height) {
                            this.projectiles.splice(i, 1);
                        }
                    }

                    this.weapons = this.weapons.filter(w => !w.isEquipped);

                    this.effects.forEach(e => e.update());
                    this.effects = this.effects.filter(e => e.duration > 0);
                    this.areaEffects.forEach(e => e.update());
                    this.areaEffects = this.areaEffects.filter(e => e.duration > 0);
                }
               
                draw(mouseEvent = null) {
                    ctx.save();
                    ctx.fillStyle = '#1f2937';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);

                    const cam = this.actionCam;
                    ctx.translate(canvas.width / 2, canvas.height / 2);
                    ctx.scale(cam.current.scale, cam.current.scale);
                    ctx.translate(-cam.current.x, -cam.current.y);

                    this.drawMap();
                   
                    if (this.state === 'SIMULATE' || this.state === 'PAUSED' || this.state === 'ENDING') {
                        if (this.autoMagneticField.isActive) {
                            ctx.fillStyle = `rgba(168, 85, 247, 0.2)`;
                            const b = this.autoMagneticField.currentBounds;
                            ctx.fillRect(0, 0, b.minX * GRID_SIZE, canvas.height);
                            ctx.fillRect(b.maxX * GRID_SIZE, 0, canvas.width - b.maxX * GRID_SIZE, canvas.height);
                            ctx.fillRect(b.minX * GRID_SIZE, 0, (b.maxX - b.minX) * GRID_SIZE, b.minY * GRID_SIZE);
                            ctx.fillRect(b.minX * GRID_SIZE, b.maxY * GRID_SIZE, (b.maxX - b.minX) * GRID_SIZE, canvas.height - b.maxY * GRID_SIZE);
                        }

                        this.growingFields.forEach(field => {
                            if (field.delayTimer < field.delay) return;
                            ctx.fillStyle = `rgba(168, 85, 247, 0.2)`;
                            const startX = field.gridX * GRID_SIZE;
                            const startY = field.gridY * GRID_SIZE;
                            const totalWidth = field.width * GRID_SIZE;
                            const totalHeight = field.height * GRID_SIZE;

                            if (field.direction === 'DOWN') ctx.fillRect(startX, startY, totalWidth, totalHeight * field.progress);
                            else if (field.direction === 'UP') ctx.fillRect(startX, startY + totalHeight * (1 - field.progress), totalWidth, totalHeight * field.progress);
                            else if (field.direction === 'RIGHT') ctx.fillRect(startX, startY, totalWidth * field.progress, totalHeight);
                            else if (field.direction === 'LEFT') ctx.fillRect(startX + totalWidth * (1 - field.progress), startY, totalWidth * field.progress, totalHeight);
                        });
                    }
                   
                    this.growingFields.forEach(w => w.draw());
                    this.weapons.forEach(w => w.draw());
                    this.nexuses.forEach(n => n.draw());
                    this.projectiles.forEach(p => p.draw());
                    this.units.forEach(u => u.draw());
                    this.effects.forEach(e => e.draw());
                    this.areaEffects.forEach(e => e.draw());

                    if (this.state === 'EDIT' && this.currentTool.tool === 'growing_field' && this.dragStartPos && this.isPainting && mouseEvent) {
                        const currentPos = this.getMousePos(mouseEvent);
                        const x = Math.min(this.dragStartPos.gridX, currentPos.gridX) * GRID_SIZE;
                        const y = Math.min(this.dragStartPos.gridY, currentPos.gridY) * GRID_SIZE;
                        const width = (Math.abs(this.dragStartPos.gridX - currentPos.gridX) + 1) * GRID_SIZE;
                        const height = (Math.abs(this.dragStartPos.gridY - currentPos.gridY) + 1) * GRID_SIZE;
                       
                        ctx.fillStyle = 'rgba(168, 85, 247, 0.3)';
                        ctx.fillRect(x, y, width, height);
                        ctx.strokeStyle = 'rgba(168, 85, 247, 0.7)';
                        ctx.strokeRect(x, y, width, height);
                    }

                    ctx.restore();
                }

                drawMap() {
                    for (let y = 0; y < ROWS; y++) {
                        for (let x = 0; x < COLS; x++) {
                            if (!this.map || !this.map[y] || !this.map[y][x]) continue;
                            const tile = this.map[y][x];
                           
                            if (tile.type === TILE.WALL) {
                                ctx.fillStyle = tile.color || COLORS.WALL;
                            } else if (tile.type === TILE.FLOOR) {
                                ctx.fillStyle = tile.color || COLORS.FLOOR;
                            } else if (tile.type === TILE.LAVA) ctx.fillStyle = COLORS.LAVA;
                            else if (tile.type === TILE.CRACKED_WALL) ctx.fillStyle = COLORS.CRACKED_WALL;
                            else if (tile.type === TILE.HEAL_PACK) ctx.fillStyle = COLORS.HEAL_PACK;
                            else if (tile.type === TILE.REPLICATION_TILE) ctx.fillStyle = COLORS.REPLICATION_TILE;
                            else {
                                ctx.fillStyle = COLORS.FLOOR;
                            }
                           
                            ctx.fillRect(x * GRID_SIZE, y * GRID_SIZE, GRID_SIZE, GRID_SIZE);

                            if(tile.type === TILE.LAVA) {
                                const flicker = Math.sin(this.animationFrameCounter * 0.1 + x + y) * 10 + 10;
                                ctx.fillStyle = `rgba(255, 255, 0, 0.3)`;
                                ctx.beginPath(); ctx.arc(x * GRID_SIZE + 10, y * GRID_SIZE + 10, flicker / 4, 0, Math.PI * 2); ctx.fill();
                            }
                            if(tile.type === TILE.CRACKED_WALL) {
                                ctx.strokeStyle = 'rgba(0,0,0,0.7)'; ctx.lineWidth = 1.5;
                                ctx.beginPath();
                                ctx.moveTo(x * GRID_SIZE + 4, y * GRID_SIZE + 4); ctx.lineTo(x * GRID_SIZE + 10, y * GRID_SIZE + 10);
                                ctx.moveTo(x * GRID_SIZE + 10, y * GRID_SIZE + 10); ctx.lineTo(x * GRID_SIZE + 8, y * GRID_SIZE + 16);
                                ctx.moveTo(x * GRID_SIZE + 16, y * GRID_SIZE + 5); ctx.lineTo(x * GRID_SIZE + 10, y * GRID_SIZE + 9);
                                ctx.moveTo(x * GRID_SIZE + 10, y * GRID_SIZE + 9); ctx.lineTo(x * GRID_SIZE + 15, y * GRID_SIZE + 17);
                                ctx.stroke();
                            }
                             if(tile.type === TILE.TELEPORTER) {
                                const angle = this.animationFrameCounter * 0.05;
                                ctx.save();
                                ctx.translate(x * GRID_SIZE + GRID_SIZE / 2, y * GRID_SIZE + GRID_SIZE / 2);
                                ctx.rotate(angle);
                                for (let i = 0; i < 6; i++) {
                                    ctx.fillStyle = i % 2 === 0 ? COLORS.TELEPORTER : '#4c1d95';
                                    ctx.beginPath(); ctx.moveTo(0, 0); ctx.lineTo(GRID_SIZE * 0.5, 0);
                                    ctx.arc(0, 0, GRID_SIZE * 0.5, 0, Math.PI / 3); ctx.closePath();
                                    ctx.fill(); ctx.rotate(Math.PI / 3);
                                }
                                ctx.restore();
                            }
                            if(tile.type === TILE.HEAL_PACK) {
                                ctx.fillStyle = 'white';
                                const plusWidth = 4;
                                const plusLength = GRID_SIZE - 8;
                                ctx.fillRect(x * GRID_SIZE + (GRID_SIZE - plusWidth) / 2, y * GRID_SIZE + 4, plusWidth, plusLength);
                                ctx.fillRect(x * GRID_SIZE + 4, y * GRID_SIZE + (GRID_SIZE - plusWidth) / 2, plusLength, plusWidth);
                            }
                            if(tile.type === TILE.REPLICATION_TILE) {
                                ctx.fillStyle = 'black'; ctx.font = 'bold 12px Arial'; ctx.textAlign = 'center';
                                ctx.fillText(`+${tile.replicationValue}`, x * GRID_SIZE + 10, y * GRID_SIZE + 14);
                            }

                            if (this.state === 'EDIT') {
                                ctx.strokeStyle = COLORS.GRID;
                                ctx.strokeRect(x * GRID_SIZE, y * GRID_SIZE, GRID_SIZE, GRID_SIZE);
                            }
                        }
                    }
                }
               
                hasLineOfSight(startUnit, endTarget) {
                    let x1 = Math.floor(startUnit.pixelX / GRID_SIZE);
                    let y1 = Math.floor(startUnit.pixelY / GRID_SIZE);
                    const x2 = Math.floor(endTarget.pixelX / GRID_SIZE);
                    const y2 = Math.floor(endTarget.pixelY / GRID_SIZE);
                    const dx = Math.abs(x2 - x1), dy = Math.abs(y2 - y1);
                    const sx = (x1 < x2) ? 1 : -1, sy = (y1 < y2) ? 1 : -1;
                    let err = dx - dy;

                    while (true) {
                        if ((x1 === x2 && y1 === y2)) break;
                        const e2 = 2 * err;
                        if (e2 > -dy) { err -= dy; x1 += sx; }
                        if (e2 < dx) { err += dx; y1 += sy; }
                        if ((x1 === x2 && y1 === y2)) break;
                        if (y1 < 0 || y1 >= ROWS || x1 < 0 || x1 >= COLS) return false;
                        const tile = this.map[y1][x1];
                        if (tile.type === TILE.WALL || tile.type === TILE.CRACKED_WALL) {
                            return false;
                        }
                    }
                    return true;
                }

                createWeapon(x, y, type) {
                    const weapon = new Weapon(x, y, type);
                    if (type === 'sword') {
                        weapon.attackPowerBonus = 15;
                    } else if (type === 'bow') {
                        weapon.attackPowerBonus = 10;
                        weapon.attackRangeBonus = 5 * GRID_SIZE;
                        weapon.detectionRangeBonus = 4 * GRID_SIZE;
                    } else if (type === 'dual_swords') {
                        weapon.attackPowerBonus = 3;
                        weapon.speedBonus = 0.6;
                        weapon.attackCooldownBonus = -40;
                    } else if (type === 'staff') {
                        weapon.attackPowerBonus = 25;
                        weapon.attackRangeBonus = 6 * GRID_SIZE;
                        weapon.detectionRangeBonus = 2 * GRID_SIZE;
                    } else if (type === 'hadoken') {
                        weapon.attackPowerBonus = 20;
                        weapon.attackRangeBonus = 5 * GRID_SIZE;
                        weapon.detectionRangeBonus = 4 * GRID_SIZE;
                    } else if (type === 'shuriken') {
                        weapon.attackPowerBonus = 12;
                        weapon.speedBonus = 0.3;
                        weapon.attackCooldownBonus = 100;
                        weapon.attackRangeBonus = 5 * GRID_SIZE;
                        weapon.detectionRangeBonus = 4 * GRID_SIZE;
                    } else if (type === 'crown') {
                        weapon.attackPowerBonus = 5;
                    }
                    return weapon;
                }

                spawnUnit(spawner, cloneWeapon = false) {
                    for(let dx = -1; dx <= 1; dx++) {
                        for(let dy = -1; dy <= 1; dy++) {
                            if(dx === 0 && dy === 0) continue;
                            const newX = Math.floor(spawner.pixelX / GRID_SIZE) + dx;
                            const newY = Math.floor(spawner.pixelY / GRID_SIZE) + dy;
                            if (newY >= 0 && newY < ROWS && newX >= 0 && newX < COLS && this.map[newY][newX].type === TILE.FLOOR) {
                                const isOccupied = this.units.some(u => u.gridX === newX && u.gridY === newY) || this.weapons.some(w => w.gridX === newX && w.gridY === newY) || this.nexuses.some(n => n.gridX === newX && n.gridY === newY);
                                if (!isOccupied) {
                                    const newUnit = new Unit(newX, newY, spawner.team);
                                    if (cloneWeapon && spawner.weapon) {
                                        newUnit.equipWeapon(spawner.weapon.type, true);
                                    }
                                    this.units.push(newUnit);
                                    return;
                                }
                            }
                        }
                    }
                }
               
                createEffect(type, x, y, target) { this.effects.push(new Effect(x, y, type, target)); }
                createProjectile(owner, target, type) { this.projectiles.push(new Projectile(owner, target, type)); }
                castAreaSpell(pos, type, damage, team) {
                    this.areaEffects.push(new AreaEffect(pos.x, pos.y, type));
                    this.units.forEach(unit => {
                        if (unit.team !== team && Math.hypot(unit.pixelX - pos.x, unit.pixelY - pos.y) < GRID_SIZE * 2.5) {
                            unit.takeDamage(damage);
                        }
                    });
                    this.nexuses.forEach(nexus => {
                        if (nexus.team !== team && !nexus.isDestroying && Math.hypot(nexus.pixelX - pos.x, nexus.pixelY - pos.y) < GRID_SIZE * 2.5) {
                            nexus.takeDamage(damage);
                        }
                    });
                }
                damageTile(x, y, damage) {
                    if (y >= 0 && y < ROWS && x >= 0 && x < COLS) {
                        const tile = this.map[y][x];
                        if (tile.type === TILE.CRACKED_WALL) {
                            tile.hp -= damage;
                            if (tile.hp <= 0) {
                                this.map[y][x] = { type: TILE.FLOOR, color: this.currentFloorColor };
                                audioManager.play('crackedWallBreak');
                            }
                        }
                    }
                }
                getTilesOfType(type) {
                    const tiles = [];
                    for (let y = 0; y < ROWS; y++) {
                        for (let x = 0; x < COLS; x++) {
                            if (this.map[y][x].type === type) {
                                tiles.push({ x, y });
                            }
                        }
                    }
                    return tiles;
                }

                isPosInAnyField(gridX, gridY) {
                    if (this.autoMagneticField.isActive) {
                        const b = this.autoMagneticField.currentBounds;
                        if (gridX < b.minX || gridX >= b.maxX || gridY < b.minY || gridY >= b.maxY) {
                            return true;
                        }
                    }
                    for (const field of this.growingFields) {
                        if (field.delayTimer < field.delay) continue;

                        let isInside = false;
                        const currentProgress = field.progress;
                        const startX = field.gridX;
                        const startY = field.gridY;
                        const endX = field.gridX + field.width;
                        const endY = field.gridY + field.height;

                        if (gridX >= startX && gridX < endX && gridY >= startY && gridY < endY) {
                            if (field.direction === 'DOWN') {
                                if (gridY < startY + field.height * currentProgress) isInside = true;
                            } else if (field.direction === 'UP') {
                                if (gridY >= endY - field.height * currentProgress) isInside = true;
                            } else if (field.direction === 'RIGHT') {
                                if (gridX < startX + field.width * currentProgress) isInside = true;
                            } else if (field.direction === 'LEFT') {
                                if (gridX >= endX - field.width * currentProgress) isInside = true;
                            }
                        }
                        if (isInside) return true;
                    }
                    return false;
                }

                findClosestSafeSpot(pixelX, pixelY) {
                    let closestSpot = null;
                    let minDistance = Infinity;

                    for (let y = 0; y < ROWS; y++) {
                        for (let x = 0; x < COLS; x++) {
                            if (!this.isPosInAnyField(x, y)) {
                                const targetPixelX = x * GRID_SIZE + GRID_SIZE / 2;
                                const targetPixelY = y * GRID_SIZE + GRID_SIZE / 2;
                                const distance = Math.hypot(pixelX - targetPixelX, pixelY - targetPixelY);
                                if (distance < minDistance) {
                                    minDistance = distance;
                                    closestSpot = { x: targetPixelX, y: targetPixelY };
                                }
                            }
                        }
                    }
                    return closestSpot || { x: canvas.width / 2, y: canvas.height / 2 }; // 안전지대 없으면 중앙으로
                }

                async loadMapForEditing(mapId) {
                    const mapData = await this.getMapById(mapId);
                    if (!mapData) {
                        console.error("Map not found:", mapId);
                        this.showHomeScreen();
                        return;
                    }

                    this.currentMapName = mapData.name;
                    canvas.width = mapData.width;
                    canvas.height = mapData.height;
                    widthInput.value = mapData.width;
                    heightInput.value = mapData.height;
                    COLS = Math.floor(canvas.width / GRID_SIZE);
                    ROWS = Math.floor(canvas.height / GRID_SIZE);

                    if (mapData.map && typeof mapData.map === 'string') {
                        this.map = JSON.parse(mapData.map); // Deserialize map grid
                    } else {
                        // Fallback for old data or errors
                        this.map = Array(ROWS).fill().map(() => Array(COLS).fill({ type: TILE.FLOOR, color: COLORS.FLOOR }));
                    }
                   
                    this.units = (mapData.units || []).map(u => Object.assign(new Unit(0,0), u));
                    this.weapons = (mapData.weapons || []).map(w => Object.assign(new Weapon(0,0), w));
                    this.nexuses = (mapData.nexuses || []).map(n => Object.assign(new Nexus(0,0), n));
                    this.growingFields = (mapData.growingFields || []).map(fieldData => {
                         const settings = {
                             direction: fieldData.direction,
                             speed: (fieldData.totalFrames / 60) || 4,
                             delay: (fieldData.delay / 60) || 0,
                         };
                        return new GrowingMagneticField(fieldData.id, fieldData.gridX, fieldData.gridY, fieldData.width, fieldData.height, settings);
                    });

                    // Load saved settings
                    this.autoMagneticField = mapData.autoMagneticField || this.autoMagneticField;
                    this.hadokenKnockback = mapData.hadokenKnockback || this.hadokenKnockback;
                   
                    // 시뮬레이션 상태를 수동으로 리셋 (resetPlacement 호출 대신)
                    cancelAnimationFrame(this.animationFrameId);
                    this.animationFrameId = null;
                    this.state = 'EDIT';
                    this.effects = [];
                    this.projectiles = [];
                    this.areaEffects = [];
                    this.initialUnitsState = [];
                    this.initialWeaponsState = [];
                    this.initialNexusesState = [];
                    this.initialMapState = [];
                    this.initialGrowingFieldsState = [];
                    statusText.textContent = "에디터 모드";
                    simStartBtn.classList.remove('hidden');
                    simPauseBtn.classList.add('hidden');
                    simPlayBtn.classList.add('hidden');
                    simStartBtn.disabled = false;
                    toolbox.style.pointerEvents = 'auto';
                    this.resetActionCam(true);
                    this.draw();
                }
            }

            // --- 게임 시작 ---
            gameManager = new GameManager();
            if (currentUser) {
                gameManager.init();
            }
        });
    </script>
</body>
</html>
